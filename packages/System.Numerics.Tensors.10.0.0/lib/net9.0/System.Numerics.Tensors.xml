<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Numerics.Tensors</name>
    </assembly>
    <members>
        <member name="T:System.Numerics.Tensors.TensorPrimitives">
            <summary>Performs primitive tensor operations over spans of memory.</summary>
            <summary>Performs primitive tensor operations over spans of memory.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Abs(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise absolute value of each single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Abs(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The absolute value of a <see cref="T:System.Single"/> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/> or <see cref="F:System.Single.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            If a value is equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and the length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cosh(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise hyperbolic cosine of each single-precision floating-point radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Cosh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/> or <see cref="F:System.Single.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            If a value is equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is also NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <see cref="F:System.MathF.PI"/>/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The cosine similarity of the two tensors.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (MathF.Sqrt(TensorPrimitives.SumOfSquares(x)) * MathF.Sqrt(TensorPrimitives.SumOfSquares(y)).</c>
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NegativeInfinity"/>, <see cref="F:System.Single.PositiveInfinity"/>, or <see cref="F:System.Single.NaN"/>,
            NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Distance(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of single-precision floating-point numbers, in Euclidean space.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The Euclidean distance.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                float result = MathF.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NaN"/>, NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Dot(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the dot product of two tensors containing single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The dot product.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                float result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input elements is equal to <see cref="F:System.Single.NaN"/>, the resulting value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Exp(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals <see cref="F:System.Single.NaN"/> or <see cref="F:System.Single.PositiveInfinity"/>, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="F:System.Single.NegativeInfinity"/>, the result stored into the corresponding destination location is set to 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the largest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the maximum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the largest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the smallest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the minimum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the index of the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the smallest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise natural (base <c>e</c>) logarithm of single-precision floating-point numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log2(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise base 2 logarithm of single-precision floating-point numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log2(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="F:System.Single.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the largest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The maximum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise maximum of the single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the largest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise single-precision floating-point number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the smallest single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The minimum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise minimum of the single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single})">
            <summary>Searches for the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the smallest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise single-precision floating-point number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="F:System.Single.NaN"/>,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Negate(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise negation of each single-precision floating-point number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Norm(System.ReadOnlySpan{System.Single})">
            <summary>Computes the Euclidean norm of the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <returns>The norm.</returns>
            <remarks>
            <para>
            This method effectively computes <c>MathF.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Product(System.ReadOnlySpan{System.Single})">
            <summary>Computes the product of all elements in the specified non-empty tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of multiplying all elements in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the product of the element-wise differences of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                float result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>Computes the product of the element-wise sums of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                float result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <see cref="T:System.MathF" />.Exp(-<paramref name="x" />[i]))</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sinh(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise hyperbolic sine of each single-precision floating-point radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Sinh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/>, <see cref="F:System.Single.PositiveInfinity"/>, or <see cref="F:System.Single.NaN"/>,
            the corresponding destination location is set to that value.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <see cref="F:System.MathF.PI"/>/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SoftMax(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the softmax function over the specified non-empty tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes a sum of <c>MathF.Exp(x[i])</c> for all elements in <paramref name="x"/>.
            It then effectively computes <c><paramref name="destination" />[i] = MathF.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})">
            <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sum(System.ReadOnlySpan{System.Single})">
            <summary>Computes the sum of all elements in the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding all elements in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            If any of the values in the input is equal to <see cref="F:System.Single.NaN"/>, the result is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes(System.ReadOnlySpan{System.Single})">
            <summary>Computes the sum of the absolute values of every element in the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the absolute value of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                float result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares(System.ReadOnlySpan{System.Single})">
            <summary>Computes the sum of the square of every element in the specified tensor of single-precision floating-point numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the square of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                float result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Tanh(System.ReadOnlySpan{System.Single},System.Span{System.Single})">
            <summary>Computes the element-wise hyperbolic tangent of each single-precision floating-point radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Tanh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity"/>, the corresponding destination location is set to -1.
            If a value is equal to <see cref="F:System.Single.PositiveInfinity"/>, the corresponding destination location is set to 1.
            If a value is equal to <see cref="F:System.Single.NaN"/>, the corresponding destination location is set to NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <see cref="F:System.MathF.PI"/>/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ValidateInputOutputSpanNonOverlapping``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Throws an exception if the <paramref name="input"/> and <paramref name="destination"/> spans overlap and don't begin at the same memory location.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ValidateOutputSpansNonOverlapping``1(System.Int32,System.Span{``0},System.Span{``0})">
            <summary>
            Throws an exception if the region of <paramref name="destination1"/> that will store results and the
            region of <paramref name="destination2"/> that will store results overlap.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ThrowNegateTwosCompOverflow">
            <summary>Throws an <see cref="T:System.OverflowException"/> for trying to negate the minimum value of a two-complement value.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Rename``2(System.Span{``0})">
            <summary>Creates a span of <typeparamref name="TTo"/> from a <typeparamref name="TFrom"/> when they're the same type.</summary>
            <remarks>
            This is the same as MemoryMarshal.Cast, except only to be used when TFrom and TTo are the same type or effectively
            the same type (e.g. int and nint in a 32-bit process). MemoryMarshal.Cast can't currently be used as it's
            TFrom/TTo are constrained to be value types.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Rename``2(System.ReadOnlySpan{``0})">
            <summary>Creates a span of <typeparamref name="TTo"/> from a <typeparamref name="TFrom"/> when they're the same type.</summary>
            <remarks>
            This is the same as MemoryMarshal.Cast, except only to be used when TFrom and TTo are the same type or effectively
            the same type (e.g. int and nint in a 32-bit process). MemoryMarshal.Cast can't currently be used as it's
            TFrom/TTo are constrained to be value types.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPrimitiveBinaryInteger``1">
            <summary>Gets whether <typeparamref name="T"/> is a built-in binary integer type.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentByteMask_64x65">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 64 rows of 64 bytes. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 65 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 64 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentUInt16Mask_32x33">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 32 rows of 32 uints. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 33 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 32 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentUInt32Mask_16x17">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 16 rows of 16 uints. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 17 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 16 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.AlignmentUInt64Mask_8x9">
             <summary>Mask used to handle alignment elements before vectorized handling of the input.</summary>
             <remarks>
             Logically 8 rows of 8 ulongs. The Nth row should be used to handle N alignment elements at the
             beginning of the input, where elements in the vector after that will be zero'd.
            
             There actually exists 9 rows in the table with the last row being a repeat of the first. This is
             done because it allows the main algorithms to use a simplified algorithm when computing the amount
             of misalignment where we always skip the first 8 elements, even if already aligned, so we don't
             double process them. This allows us to avoid an additional branch.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderByteMask_64x65">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 64 rows of 64 ushorts. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 65 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 16 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderUInt16Mask_32x33">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 32 rows of 32 ushorts. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 33 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 16 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderUInt32Mask_16x17">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 16 rows of 16 uints. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 17 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 16 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.TensorPrimitives.RemainderUInt64Mask_8x9">
             <summary>Mask used to handle remaining elements after vectorized handling of the input.</summary>
             <remarks>
             Logically 8 rows of 8 ulongs. The Nth row should be used to handle N remaining elements at the
             end of the input, where elements in the vector prior to that will be zero'd.
            
             Much as with the AlignmentMask table, we actually have 9 rows where the last row is a repeat of
             the first. Doing this allows us to avoid an additional branch and instead to always process the
             last 8 elements via a conditional select instead.
             </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IAggregationOperator`1">
            <summary><see cref="T:System.Numerics.Tensors.TensorPrimitives.IBinaryOperator`1"/> that specializes horizontal aggregation of all elements in a vector.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.StatefulUnaryAdapterOperator`2">
            <summary>Adapts a stateless <see cref="T:System.Numerics.Tensors.TensorPrimitives.IUnaryOperator`2"/> to be used as a stateful <see cref="T:System.Numerics.Tensors.TensorPrimitives.IStatefulUnaryOperator`1"/>.</summary>
            <typeparam name="TOperator"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Aggregate``3(System.ReadOnlySpan{``0})">
            <summary>Performs an aggregation over all elements in <paramref name="x"/> to produce a single-precision floating-point value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTransformOperator">Specifies the transform operation that should be applied to each element loaded from <paramref name="x"/>.</typeparam>
            <typeparam name="TAggregationOperator">
            Specifies the aggregation binary operation that should be applied to multiple values to aggregate them into a single value.
            The aggregation is applied after the transform is applied to each element.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Aggregate``3(System.ReadOnlySpan{``0},``1)">
            <summary>Performs an aggregation over all elements in <paramref name="x"/> to produce a single-precision floating-point value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTransformOperator">Specifies the transform operation that should be applied to each element loaded from <paramref name="x"/>.</typeparam>
            <typeparam name="TAggregationOperator">
            Specifies the aggregation binary operation that should be applied to multiple values to aggregate them into a single value.
            The aggregation is applied after the transform is applied to each element.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Aggregate``3(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Performs an aggregation over all pair-wise elements in <paramref name="x"/> and <paramref name="y"/> to produce a single-precision floating-point value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator">Specifies the binary operation that should be applied to the pair-wise elements loaded from <paramref name="x"/> and <paramref name="y"/>.</typeparam>
            <typeparam name="TAggregationOperator">
            Specifies the aggregation binary operation that should be applied to multiple values to aggregate them into a single value.
            The aggregation is applied to the results of the binary operations on the pair-wise values.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateAlignmentMaskVector128``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateAlignmentMaskVector256``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateAlignmentMaskVector512``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateRemainderMaskVector128``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateRemainderMaskVector256``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CreateRemainderMaskVector512``1(System.Int32)">
            <summary>
            Gets a vector mask that will be all-ones-set for the last <paramref name="count"/> elements
            and zero for all other elements.
            </summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IBinaryOperator`1">
            <summary>Operator that takes two input values and returns a single value.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeScalarSpanIntoSpan``2(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator">
            Specifies the operation to perform on each element loaded from <paramref name="x"/> with <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarIntoSpan``2(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator">
            Specifies the operation to perform on each element loaded from <paramref name="x"/> with <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanSpanIntoSpan``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TBinaryOperator{T}{T}">
            Specifies the operation to perform on the pair-wise elements loaded from <paramref name="x"/> and <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarIntoSpan``3(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTransformOperator">
            Specifies the operation to perform on each element loaded from <paramref name="x"/>.
            It is not used with <paramref name="y"/>.
            </typeparam>
            <typeparam name="TBinaryOperator">
            Specifies the operation to perform on the transformed value from <paramref name="x"/> with <paramref name="y"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HorizontalAggregate``2(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Aggregates all of the elements in the <paramref name="x"/> into a single value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TAggregate">Specifies the operation to be performed on each pair of values.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HorizontalAggregate``2(System.Runtime.Intrinsics.Vector512{``0})">
            <summary>Aggregates all of the elements in the <paramref name="x"/> into a single value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TAggregate">Specifies the operation to be performed on each pair of values.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HorizontalAggregate``2(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Aggregates all of the elements in the <paramref name="x"/> into a single value.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TAggregate">Specifies the operation to be performed on each pair of values.</typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IBooleanUnaryOperator`1">
            <summary>Unary operator that produces a Boolean result for each element.</summary>
            <remarks>For vector-based methods, the Boolean result is either all-bits-set or zero.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan``2(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="T">The element input type.</typeparam>
            <typeparam name="TOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IStatefulUnaryOperator`1">
            <summary>Operator that takes one input value and returns a single value.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan``2(System.ReadOnlySpan{``0},``1,System.Span{``0})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TStatefulUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ITernaryOperator`1">
            <summary>Operator that takes three input values and returns a single value.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanSpanSpanIntoSpan``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/>, <paramref name="y"/>, and <paramref name="z"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTernaryOperator">
            Specifies the operation to perform on the pair-wise elements loaded from <paramref name="x"/>, <paramref name="y"/>,
            and <paramref name="z"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanSpanScalarIntoSpan``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/>, <paramref name="y"/>, and <paramref name="z"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTernaryOperator">
            Specifies the operation to perform on the pair-wise elements loaded from <paramref name="x"/> and <paramref name="y"/>
            with <paramref name="z"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarSpanIntoSpan``2(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/>, <paramref name="y"/>, and <paramref name="z"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTernaryOperator">
            Specifies the operation to perform on the pair-wise element loaded from <paramref name="x"/>, with <paramref name="y"/>,
            and the element loaded from <paramref name="z"/>.
            </typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarScalarIntoSpan``2(System.ReadOnlySpan{``0},``0,``0,System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/>, <paramref name="y"/>, and <paramref name="z"/>,
            and writes the results to <paramref name="destination"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TTernaryOperator">
            Specifies the operation to perform on the pair-wise elements loaded from <paramref name="x"/> and <paramref name="y"/>
            with <paramref name="z"/>.
            </typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryInputBinaryOutput`1">
            <summary>Operator that takes one input value and returns two output values.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IBinaryInputBinaryOutput`1">
            <summary>Operator that takes two input values and returns two output values.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpanSpan``2(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination1"/> and <paramref name="destination2"/>.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanSpanIntoSpanSpan``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/> and writes the results
            to <paramref name="destination1"/> and <paramref name="destination2"/>.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanScalarIntoSpanSpan``2(System.ReadOnlySpan{``0},``0,System.Span{``0},System.Span{``0})">
            <summary>
            Performs an element-wise operation on <paramref name="x"/> and <paramref name="y"/> and writes the results
            to <paramref name="destination1"/> and <paramref name="destination2"/>.</summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryOneToTwoOperator`2">
            <summary>Operator that takes one input value and returns a single value.</summary>
            <remarks>The input type must be half the size of the output type.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan_1to2``3(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="TInput">The element input type.</typeparam>
            <typeparam name="TOutput">The element output type. Must be twice the size of TInput.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
            <remarks>This should only be used when it's known that TInput/TOutput are vectorizable and the size of TInput is half that of TOutput.</remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryOneToFourOperator`2">
            <summary>Operator that takes one input value and returns a single value.</summary>
            <remarks>The input type must be a quarter of the size of the output type.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan_1to4``3(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="TInput">The element input type.</typeparam>
            <typeparam name="TOutput">The element output type. Must be four times the size of TInput.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
            <remarks>This should only be used when it's known that TInput/TOutput are vectorizable and the size of TInput is a fourth that of TOutput.</remarks>
        </member>
        <member name="F:System.Numerics.Tensors.TensorPrimitives.NonTemporalByteThreshold">
             <summary>Defines the threshold, in bytes, at which non-temporal stores will be used.</summary>
             <remarks>
                 A non-temporal store is one that allows the CPU to bypass the cache when writing to memory.
            
                 This can be beneficial when working with large amounts of memory where the writes would otherwise
                 cause large amounts of repeated updates and evictions. The hardware optimization manuals recommend
                 the threshold to be roughly half the size of the last level of on-die cache -- that is, if you have approximately
                 4MB of L3 cache per core, you'd want this to be approx. 1-2MB, depending on if hyperthreading was enabled.
            
                 However, actually computing the amount of L3 cache per core can be tricky or error prone. Native memcpy
                 algorithms use a constant threshold that is typically around 256KB and we match that here for simplicity. This
                 threshold accounts for most processors in the last 10-15 years that had approx. 1MB L3 per core and support
                 hyperthreading, giving a per core last level cache of approx. 512KB.
             </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryOperator`2">
            <summary>Operator that takes one input value and returns a single value.</summary>
            <remarks>The input and output type must be of the same size if vectorization is desired.</remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IdentityOperator`1">
            <summary>x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan``2(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="T">The element input type.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan``3(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="TInput">The element input type.</typeparam>
            <typeparam name="TOutput">The element output type. Must be the same size as TInput if TInput and TOutput both support vectorization.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
            <remarks>
            This supports vectorizing the operation if <typeparamref name="TInput"/> and <typeparamref name="TOutput"/> are the same size.
            Otherwise, it'll fall back to scalar operations.
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IUnaryTwoToOneOperator`2">
            <summary>Operator that takes one input value and returns a single value.</summary>
            <remarks>The input type must be twice the size of the output type.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.InvokeSpanIntoSpan_2to1``3(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs an element-wise operation on <paramref name="x"/> and writes the results to <paramref name="destination"/>.</summary>
            <typeparam name="TInput">The element input type.</typeparam>
            <typeparam name="TOutput">The element output type. Must be the same size as TInput if TInput and TOutput both support vectorization.</typeparam>
            <typeparam name="TUnaryOperator">Specifies the operation to perform on each element loaded from <paramref name="x"/>.</typeparam>
            <remarks>This should only be used when it's known that TInput/TOutput are vectorizable and the size of TInput is twice that of TOutput.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Abs``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise absolute value of each number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.OverflowException"><typeparamref name="T"/> is a signed integer type and <paramref name="x"/> contained a value equal to <typeparamref name="T"/>'s minimum value.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Abs(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The absolute value of a <typeparamref name="T"/> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AbsoluteOperator`1">
            <summary>T.Abs(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Acos``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose cosine is the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Acos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AcosOperator`1">
            <summary>T.Acos(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Acosh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic arc-cosine of the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Acosh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AcoshOperator`1">
            <summary>T.Acosh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AcosPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose cosine is the specifed number and divides the result by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.AcosPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AcosPiOperator`1">
            <summary>T.AcosPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AddOperator`1">
            <summary>x + y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and the length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="multiplier">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="multiplier">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="multiplier" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="multiplier"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AddMultiplyOperator`1">
            <summary>(x + y) * z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Asin``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose sine is the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Asin(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AsinOperator`1">
            <summary>T.Asin(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Asinh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic arc-sine of the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Asinh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AsinhOperator`1">
            <summary>T.Asinh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AsinPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose sine is the specifed number and divides the result by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.AsinPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AsinPiOperator`1">
            <summary>T.AsinPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose tangent is the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AtanOperator`1">
            <summary>T.Atan(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="y" /> must be same as length of <paramref name="x" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
            <param name="y">The first tensor, represented as a scalar.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Atan2Operator`1">
            <summary>T.Atan2(y, x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="y" /> must be same as length of <paramref name="x" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
            <param name="y">The first tensor, represented as a span.</param>
            <param name="x">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
            <param name="y">The first tensor, represented as a scalar.</param>
            <param name="x">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Atan2PiOperator`1">
            <summary>T.Atan2Pi(y, x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Atanh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic arc-tangent of the specifed number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Atanh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AtanhOperator`1">
            <summary>T.Atanh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AtanPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise angle in radians whose tangent is the specifed number and divides the result by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.AtanPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.AtanPiOperator`1">
            <summary>T.AtanPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Average``1(System.ReadOnlySpan{``0})">
            <summary>Computes the mean of all elements in the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The mean of all elements in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitDecrement``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise bit decrement of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.BitDecrement(<paramref name="x" />[i])</c>.
            Each element is decremented to the largest value that compares less than the original.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.BitDecrementOperator`1">
            <summary>T.BitDecrement(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitIncrement``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise bit increment of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.BitIncrement(<paramref name="x" />[i])</c>.
            Each element is incremented to the smallest value that compares greater than the original.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.BitIncrementOperator`1">
            <summary>T.BitIncrement(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" /></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.BitwiseAndOperator`1">
            <summary>x &amp; y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" /></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.BitwiseOrOperator`1">
            <summary>x | y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cbrt``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise cube root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Cbrt(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CbrtOperator`1">
            <summary>T.Cbrt(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ceiling``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise ceiling of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ceiling(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Computes the element-wise result of clamping <paramref name="x"/> to within the inclusive range specified
            by <paramref name="min"/> and <paramref name="max"/> for the specified tensors.
            </summary>
            <param name="x">The tensor of values to clamp, represented as a span.</param>
            <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
            <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">An element-wise <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="min" /> and the length of <paramref name="max" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="min"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="max"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />[i], <paramref name="max" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Computes the element-wise result of clamping <paramref name="x"/> to within the inclusive range specified
            by <paramref name="min"/> and <paramref name="max"/> for the specified tensors.
            </summary>
            <param name="x">The tensor of values to clamp, represented as a span.</param>
            <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
            <param name="max">The tensor of inclusive upper bounds, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">An element-wise <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="min" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="min"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />[i], <paramref name="max" />)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Computes the element-wise result of clamping <paramref name="x"/> to within the inclusive range specified
            by <paramref name="min"/> and <paramref name="max"/> for the specified tensors.
            </summary>
            <param name="x">The tensor of values to clamp, represented as a span.</param>
            <param name="min">The tensor of inclusive lower bounds, represented as a scalar.</param>
            <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">An element-wise <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="max" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="max"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />, <paramref name="max" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(``0,System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Computes the element-wise result of clamping <paramref name="x"/> to within the inclusive range specified
            by <paramref name="min"/> and <paramref name="max"/> for the specified tensors.
            </summary>
            <param name="x">The tensor of values to clamp, represented as a scalar.</param>
            <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
            <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">An element-wise <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <exception cref="T:System.ArgumentException">Length of <paramref name="min" /> must be same as length of <paramref name="max" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="min"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="max"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />, <paramref name="min" />[i], <paramref name="max" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},``0,``0,System.Span{``0})">
            <summary>
            Computes the element-wise result of clamping <paramref name="x"/> to within the inclusive range specified
            by <paramref name="min"/> and <paramref name="max"/> for the specified tensors.
            </summary>
            <param name="x">The tensor of values to clamp, represented as a span.</param>
            <param name="min">The tensor of inclusive lower bounds, represented as a scalar.</param>
            <param name="max">The tensor of inclusive upper bounds, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException"><paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />, <paramref name="max" />)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(``0,System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Computes the element-wise result of clamping <paramref name="x"/> to within the inclusive range specified
            by <paramref name="min"/> and <paramref name="max"/> for the specified tensors.
            </summary>
            <param name="x">The tensor of values to clamp, represented as a scalar.</param>
            <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
            <param name="max">The tensor of inclusive upper bounds, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">An element-wise <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="min"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />, <paramref name="min" />[i], <paramref name="max" />)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(``0,``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Computes the element-wise result of clamping <paramref name="x"/> to within the inclusive range specified
            by <paramref name="min"/> and <paramref name="max"/> for the specified tensors.
            </summary>
            <param name="x">The tensor of values to clamp, represented as a scalar.</param>
            <param name="min">The tensor of inclusive lower bounds, represented as a scalar.</param>
            <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">An element-wise <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="max"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />, <paramref name="min" />, <paramref name="max" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ClampOperatorXMinMax`1">
            <summary>T.Clamp(x, min, max)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ClampOperatorMinMaxX`1">
            <summary>T.Clamp(min, max, x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ClampOperatorMaxXMin`1">
            <summary>T.Clamp(max, x, min)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertChecked``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateChecked(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertCheckedFallbackOperator`2">
            <summary>T.CreateChecked(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.TryConvertUniversal``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>Performs conversions that are the same regardless of checked, truncating, or saturation.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertInt32ToSingle">
            <summary>(int)float</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertUInt32ToSingle">
            <summary>(uint)float</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertUInt64ToDouble">
            <summary>(double)ulong</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertInt64ToDouble">
            <summary>(double)long</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenSingleToDoubleOperator">
            <summary>(double)float</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowDoubleToSingleOperator">
            <summary>(float)double</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenByteToUInt16Operator">
            <summary>(ushort)byte</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenByteToUInt32Operator">
            <summary>(uint)byte</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenByteToSingleOperator">
            <summary>(float)byte</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenSByteToInt16Operator">
            <summary>(short)sbyte</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenUInt16ToUInt32Operator">
            <summary>(uint)ushort</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenInt16ToInt32Operator">
            <summary>(int)short</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenUInt32ToUInt64Operator">
            <summary>(ulong)uint</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.WidenInt32ToInt64Operator">
            <summary>(long)int</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsUInt32Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.UInt32"/> or <see cref="T:System.UIntPtr"/> if in a 32-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInt32Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.Int32"/> or <see cref="T:System.IntPtr"/> if in a 32-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsUInt64Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.UInt64"/> or <see cref="T:System.UIntPtr"/> if in a 64-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInt64Like``1">
            <summary>Gets whether <typeparamref name="T"/> is <see cref="T:System.Int64"/> or <see cref="T:System.IntPtr"/> if in a 64-bit process.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertSaturating``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateSaturating(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertSaturatingFallbackOperator`2">
            <summary>T.CreateSaturating(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertTruncating``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateTruncating(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertSingleToInt32">
            <summary>(float)int</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertSingleToUInt32">
            <summary>(float)uint</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertDoubleToUInt64">
            <summary>(ulong)double</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertDoubleToInt64">
            <summary>(long)double</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowUInt16ToByteOperator">
            <summary>(byte)ushort</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowInt16ToSByteOperator">
            <summary>(sbyte)short</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowUInt32ToUInt16Operator">
            <summary>(ushort)uint</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowInt32ToInt16Operator">
            <summary>(short)int</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowUInt64ToUInt32Operator">
            <summary>(uint)ulong</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NarrowInt64ToInt32Operator">
            <summary>(int)long</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertTruncatingFallbackOperator`2">
            <summary>T.CreateTruncating(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="sign">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="sign" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="sign"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="sign">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cos``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise cosine of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Cos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CosOperator`1">
            <summary>T.Cos(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Cosh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic cosine of each radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Cosh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is also NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CoshOperator`1">
            <summary>T.Cosh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The cosine similarity of the two tensors.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (<typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(x)) * <typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(y)).</c>
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarityCore``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of single-precision floating-point numbers.</summary>
            <remarks>Assumes arguments have already been validated to be non-empty and equal length.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarityHalfCore(System.ReadOnlySpan{System.Half},System.ReadOnlySpan{System.Half})">
            <summary>Provides the same implementation as <see cref="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarityCore``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})"/>, but specifically for <see cref="T:System.Half"/>.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CosPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.CosPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.CosPiOperator`1">
            <summary>T.CosPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Decrement``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise decrement of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - 1</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.DecrementOperator`1">
            <summary>T.Decrement(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.DegreesToRadians``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise conversion of each number of degrees in the specified tensor to radians.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.DegreesToRadians(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.DegreesToRadiansOperator`1">
            <summary>T.DegreesToRadians(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Distance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of numbers, in Euclidean space.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The Euclidean distance.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                T result = <typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, NaN is returned.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SubtractSquaredOperator`1">
            <summary>(x - y) * (x - y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> / <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.DivideOperator`1">
            <summary>x / y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.DivRem``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Computes the element-wise quotient and remainder of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="quotientDestination">The quotient destination tensor, represented as a span.</param>
            <param name="remainderDestination">The remainder destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="quotientDestination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="remainderDestination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> or <paramref name="y"/> and <paramref name="quotientDestination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> or <paramref name="y"/> and <paramref name="remainderDestination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c>(<paramref name="quotientDestination" />[i], <paramref name="remainderDestination"/>[i]) = T.DivRem(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise values are also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.DivRem``1(System.ReadOnlySpan{``0},``0,System.Span{``0},System.Span{``0})">
            <summary>Computes the element-wise quotient and remainder of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="quotientDestination">The quotient destination tensor, represented as a span.</param>
            <param name="remainderDestination">The remainder destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException"><paramref name="quotientDestination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="remainderDestination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="quotientDestination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="remainderDestination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c>(<paramref name="quotientDestination" />[i], <paramref name="remainderDestination"/>[i]) = T.DivRem(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise values are also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.DivRem``1(``0,System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Computes the element-wise quotient and remainder of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="quotientDestination">The quotient destination tensor, represented as a span.</param>
            <param name="remainderDestination">The remainder destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException"><paramref name="quotientDestination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="remainderDestination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="quotientDestination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="remainderDestination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c>(<paramref name="quotientDestination" />[i], <paramref name="remainderDestination"/>[i]) = T.DivRem(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise values are also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.DivRemOperator`1">
            <summary>Math.DivRem(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Dot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the dot product of two tensors containing numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The dot product.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <remarks>
            <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                T result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input elements is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, the result stored into the corresponding destination location is set to 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ExpOperator`1">
            <summary>T.Exp(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp10``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp10(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp10Operator`1">
            <summary>T.Exp10(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp10M1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp10M1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp10M1Operator`1">
            <summary>T.Exp10M1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp2``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp2(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp2Operator`1">
            <summary>T.Exp2(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Exp2M1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp2M1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Exp2M1Operator`1">
            <summary>T.Exp2M1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ExpM1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.ExpM1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ExpM1Operator`1">
            <summary>T.ExpM1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Floor``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Floor(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            This computes (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, adds <paramref name="addend"/> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend"/> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            This computes (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, adds <paramref name="addend"/> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend"/> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            This computes (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, adds <paramref name="addend"/> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x"/> * <paramref name="y"/>) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend"/> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAddOperator`1">
            <summary>(x * y) + z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertToHalf(System.ReadOnlySpan{System.Single},System.Span{System.Half})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <see cref="T:System.Single" />
            value to its nearest representable half-precision floating-point value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (Half)<paramref name="source" />[i]</c>.
            </para>
            <para>
            <paramref name="source"/> and <paramref name="destination"/> must not overlap. If they do, behavior is undefined.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertToSingle(System.ReadOnlySpan{System.Half},System.Span{System.Single})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each half-precision
            floating-point value to its nearest representable <see cref="T:System.Single"/> value.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (float)<paramref name="source" />[i]</c>.
            </para>
            <para>
            <paramref name="source"/> and <paramref name="destination"/> must not overlap. If they do, behavior is undefined.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsVectorizable(System.ReadOnlySpan{System.Half})">
            <summary>
            To vectorize Half, we need to reinterpret to short, widen to float, operate on floats, then narrow back to short, and reinterpret back to Half.
            Those widening and narrowing operations add overhead. If we're able to actually vectorize, it's worthwhile, but if it's not, we want to take
            the normal scalar path rather than going through the short-based path that won't actually be fruitful.
            </summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.HalfAsInt16UnaryOperator`1">
            <summary><see cref="T:System.Numerics.Tensors.TensorPrimitives.IUnaryOperator`2"/> wrapper for working with <see cref="T:System.Half"/> reinterpreted as <see cref="T:System.Int16"/> in order to enable vectorization.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.HalfAsInt16BinaryOperator`1">
            <summary><see cref="T:System.Numerics.Tensors.TensorPrimitives.IBinaryOperator`1"/> wrapper for working with <see cref="T:System.Half"/> reinterpreted as <see cref="T:System.Int16"/> in order to enable vectorization.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.HalfAsInt16AggregationOperator`1">
            <summary><see cref="T:System.Numerics.Tensors.TensorPrimitives.IAggregationOperator`1"/> wrapper for working with <see cref="T:System.Half"/> reinterpreted as <see cref="T:System.Int16"/> in order to enable vectorization.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.HalfAsInt16TernaryOperator`1">
            <summary><see cref="T:System.Numerics.Tensors.TensorPrimitives.ITernaryOperator`1"/> wrapper for working with <see cref="T:System.Half"/> reinterpreted as <see cref="T:System.Int16"/> in order to enable vectorization.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HammingBitDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the bitwise Hamming distance between two equal-length tensors of values.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The number of bits that differ between the two spans.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.HammingDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the Hamming distance between two equal-length tensors of values.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The number of elements that differ between the two spans.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
            <remarks>
            <para>
            This method computes the number of locations <c>i</c> where <c>!EqualityComparer&gt;T&lt;.Default.Equal(x[i], y[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.CountUnequalElements``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Counts the number of elements that are pair-wise different between the two spans.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Hypot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Hypot(<paramref name="x" />[i], <paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.HypotOperator`1">
            <summary>T.Hypot(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Ieee754RemainderOperator`1">
            <summary>T.Ieee754Remainder(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ILogB``1(System.ReadOnlySpan{``0},System.Span{System.Int32})">
            <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ILogBOperator`1">
            <summary>T.ILogB(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ILogBDoubleOperator">
            <summary>double.ILogB(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Increment``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise increment of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + 1</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IncrementOperator`1">
            <summary>T.Increment(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the largest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the maximum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to NaN
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxOperator`1">
            <summary>Returns the index of MathF.Max(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(``0)">
            <summary>Gets whether the specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the largest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the smallest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the minimum element in <paramref name="x"/>, or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to NaN
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IndexOfMinOperator`1">
            <summary>Returns the index of MathF.Min(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the index of the number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The index of the element in <paramref name="x"/> with the smallest magnitude (absolute value), or -1 if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsCanonical``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's in its canonical representation.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsCanonical(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsCanonicalAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are in their canonical representations.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are in their canonical representations; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsCanonicalAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is in its canonical representation.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is in its canonical representation; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AlwaysCanonical``1">
            <summary>Gets whether all values of the specified type are always in canonical form.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsCanonicalOperator`1">
            <summary>T.IsCanonical(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsComplexNumber``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's a complex number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsComplexNumber(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsComplexNumberAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are complex numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are complex numbers; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsComplexNumberAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is a complex number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is a complex number; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBeComplex``1">
            <summary>Gets whether any value could be complex.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsComplexNumberOperator`1">
            <summary>T.IsComplexNumber(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsEvenInteger``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's an even integral number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsEvenInteger(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsEvenIntegerAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are even integral numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are even integral numbers; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsEvenIntegerAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is an even integral number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is an even integral number; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsEvenIntegerOperator`1">
            <summary>T.IsEvenInteger(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsFinite``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's finite.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsFinite(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsFiniteAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are finite.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are finite; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsFiniteAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is finite.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is finite; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AlwaysFinite``1">
            <summary>Gets whether all values of the specified type are always finite.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsFiniteOperator`1">
            <summary>T.IsFinite(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumber``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's a imaginary number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsImaginaryNumber(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumberAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are imaginary numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are imaginary numbers; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumberAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is a imaginary number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is a imaginary number; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBeImaginary``1">
            <summary>Gets whether any value may be imaginary.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumberOperator`1">
            <summary>T.IsImaginaryNumber(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInfinity``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsInfinity(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInfinityAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are infinity; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInfinityAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is infinity; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBeInfinity``1">
            <summary>Gets whether any value could be complex.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsInfinityOperator`1">
            <summary>T.IsInfinity(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsInteger``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's an integer.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsInteger(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsIntegerAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are integers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are integers; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsIntegerAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is an integer.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is an integer; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AlwaysInteger``1">
            <summary>Gets whether all values of the specified type are integers.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsIntegerOperator`1">
            <summary>T.IsInteger(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNaN``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's a naN.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsNaN(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNaNAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are naNs.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are naNs; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNaNAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is a naN.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is a naN; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBeNaN``1">
            <summary>Gets whether any value could be complex.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsNaNOperator`1">
            <summary>T.IsNaN(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's negative.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsNegative(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are negative.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are negative; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is negative.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is negative; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBeNegative``1">
            <summary>Gets whether any value could be complex.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsNegativeOperator`1">
            <summary>T.IsNegative(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinity``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's negative infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsNegativeInfinity(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinityAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are negative infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are negative infinity; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinityAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is negative infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is negative infinity; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBeNegativeInfinity``1">
            <summary>Gets whether any value could be complex.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinityOperator`1">
            <summary>T.IsNegativeInfinity(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNormal``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's normal.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsNormal(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNormalAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are normal.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are normal; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNormalAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is normal.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is normal; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsNormalOperator`1">
            <summary>T.IsNormal(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsOddInteger``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's an odd integral number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsOddInteger(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsOddIntegerAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are odd integral numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are odd integral numbers; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsOddIntegerAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is an odd integral number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is an odd integral number; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsOddIntegerOperator`1">
            <summary>T.IsOddInteger(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositive``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's positive.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsPositive(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are positive.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are positive; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is positive.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is positive; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsPositiveOperator`1">
            <summary>T.IsPositive(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinity``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's positive infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsPositiveInfinity(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinityAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are positive infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are positive infinity; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinityAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is positive infinity.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is positive infinity; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBePositiveInfinity``1">
            <summary>Gets whether any value could be complex.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinityOperator`1">
            <summary>T.IsPositiveInfinity(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPow2``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's a power of two.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsPow2(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPow2All``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are powers of two.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are powers of two; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPow2Any``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor are powers of two.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> are powers of two; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsPow2Operator`1">
            <summary>T.IsPow2(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsRealNumber``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's a real number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsRealNumber(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsRealNumberAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are real numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are real numbers; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsRealNumberAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is a real number.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is a real number; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.AlwaysReal``1">
            <summary>Gets whether all values of the specified type are always real.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsRealNumberOperator`1">
            <summary>T.IsRealNumber(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsSubnormal``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's subnormal.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsSubnormal(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsSubnormalAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are subnormal.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are subnormal; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsSubnormalAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is subnormal.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is subnormal; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MayBeSubnormal``1">
            <summary>Gets whether any value could be complex.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsSubnormalOperator`1">
            <summary>T.IsSubnormal(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsZero``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})">
            <summary>Computes for each value in the specified tensor whether it's zero.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.IsZero(<paramref name="x" />[i])</c>.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsZeroAll``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether all of the values in the specified tensor are zero.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if all of the values in <paramref name="x"/> are zero; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsZeroAny``1(System.ReadOnlySpan{``0})">
            <summary>Computes whether any of the values in the specified tensor is zero.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>
            <see langword="true"/> if any of the values in <paramref name="x"/> is zero; otherwise, <see langword="false"/>.
            If <paramref name="x"/> is empty, <see langword="false"/> is returned.
            </returns>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.IsZeroOperator`1">
            <summary>T.IsZero(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.LeadingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise leading zero count of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.LeadingZeroCount(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LeadingZeroCountOperator`1">
            <summary>T.LeadingZeroCount(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="amount">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="amount" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="amount"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />[i])</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="amount">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />)</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="amount">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="amount" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="amount"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />, <paramref name="amount" />[i])</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LerpOperator`1">
            <summary>(x * (1 - z)) + (y * z)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LogOperator`1">
            <summary>T.Log(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LogBaseOperator`1">
            <summary>T.Log(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log10``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log10(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 10 logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log10Operator`1">
            <summary>T.Log10(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log10P1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor plus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log10P1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 10 logarithm plus 1 is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log10P1Operator`1">
            <summary>T.Log10P1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log2``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log2(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 2 logarithm is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log2Operator`1">
            <summary>T.Log2(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Log2P1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor plus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Log2P1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its base 2 logarithm plus 1 is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.Log2P1Operator`1">
            <summary>T.Log2P1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.LogP1``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor plus 1.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.LogP1(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>.
            Otherwise, if a value is positive, its natural logarithm plus 1 is stored into the corresponding destination location.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.LogP1Operator`1">
            <summary>T.LogP1(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the largest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The maximum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxOperator`1">
            <summary>Max(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNaN``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is NaN.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNaN``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is NaN.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNaN``1(System.Runtime.Intrinsics.Vector512{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is NaN.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.Runtime.Intrinsics.Vector512{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is negative.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositive``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is positive.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositive``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is positive.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.IsPositive``1(System.Runtime.Intrinsics.Vector512{``0})">
            <summary>Gets whether each specified <see cref="T:System.Single"/> is positive.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMaxCore``2(System.ReadOnlySpan{``0})">
            <remarks>
            This is the same as <see cref="M:System.Numerics.Tensors.TensorPrimitives.Aggregate``3(System.ReadOnlySpan{``0})"/>
            with an identity transform, except it early exits on NaN.
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the largest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
            <remarks>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeOperator`1">
            <summary>Operator to get x or y based on which has the larger MathF.Abs</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the largest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumberOperator`1">
            <summary>Operator to get x or y based on which has the larger MathF.Abs</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the largest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The maximum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MaxNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MaxNumberOperator`1">
            <summary>T.MaxNumber(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the smallest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The minimum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinOperator`1">
            <summary>T.Min(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the smallest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
            <remarks>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeOperator`1">
            <summary>Operator to get x or y based on which has the smaller MathF.Abs</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The element in <paramref name="x"/> with the smallest magnitude (absolute value).</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumberOperator`1">
            <summary>Operator to get x or y based on which has the smaller MathF.Abs</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0})">
            <summary>Searches for the smallest number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The minimum element in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimumNumber` function. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.MinNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MinNumberOperator`1">
            <summary>T.MinNumber(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyOperator`1">
            <summary>x * y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyAddOperator`1">
            <summary>(x * y) + z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" /> and length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})"/> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})"/> depending on the current machine's capabilities.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="addend">The third tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})"/> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})"/> depending on the current machine's capabilities.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="addend">The third tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="addend" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="addend"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})"/> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})"/> depending on the current machine's capabilities.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimateOperator`1">
            <summary>(x * y) + z</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Negate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise negation of each number in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
            <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.NegateOperator`1">
            <summary>-x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Norm``1(System.ReadOnlySpan{``0})">
            <summary>Computes the Euclidean norm of the specified tensor of numbers.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <returns>The norm.</returns>
            <remarks>
            <para>
            This method effectively computes <c><typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.OnesComplement``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise one's complement of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = ~<paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.OnesComplementOperator`1">
            <summary>~x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.PopCount``1(System.ReadOnlySpan{``0})">
            <summary>Computes the population count of all elements in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The sum of the number of bits set in each element in <paramref name="x"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.PopCount``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.PopCount(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.PopCountOperator`1">
            <summary>T.PopCount(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.PowOperator`1">
            <summary>T.Pow(x, y)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Product``1(System.ReadOnlySpan{``0})">
            <summary>Computes the product of all elements in the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of multiplying all elements in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result value is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the product of the element-wise differences of the numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                T result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Computes the product of the element-wise sums of the numbers in the specified non-empty tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
            <exception cref="T:System.ArgumentException">Length of both input spans must be greater than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="y"/> must have the same length.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                T result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RadiansToDegrees``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.RadiansToDegrees(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RadiansToDegreesOperator`1">
            <summary>T.RadiansToDegrees(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Reciprocal``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrt``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrtEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="x"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Remainder``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise remainder of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="destination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> or <paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] % <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise values are also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Remainder``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise remainder of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException"><paramref name="destination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] % <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise values are also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Remainder``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise remainder of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException"><paramref name="destination"/> is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.DivideByZeroException"><typeparamref name="T"/> is an integer type and an element in <paramref name="y"/> is equal to zero.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> % <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise values are also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RemainderOperator`1">
            <summary>x % y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RootN``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="n">The degree of the root to be computed, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RootN(<paramref name="x" />[i], <paramref name="n"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RootNOperator`1">
            <summary>T.RootN(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RootNOperator`1.#ctor(System.Int32)">
            <summary>T.RootN(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateLeft(<paramref name="x" />[i], <paramref name="rotateAmount"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateRight``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateRight(<paramref name="x" />[i], <paramref name="rotateAmount"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RotateLeftOperator`1">
            <summary>T.RotateLeft(amount)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateLeftOperator`1.#ctor(System.Int32)">
            <summary>T.RotateLeft(amount)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RotateRightOperator`1">
            <summary>T.RotateRight(amount)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RotateRightOperator`1.#ctor(System.Int32)">
            <summary>T.RotateRight(amount)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.MidpointRounding,System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="mode"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.MidpointRounding,System.Span{``0})">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
            <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits"/> is invalid.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="mode"/> is invalid.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits"/>, <paramref name="mode"/>)</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RoundToEvenOperator`1">
            <summary>T.Round(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RoundAwayFromZeroOperator`1">
            <summary>T.Round(x, MidpointRounding.AwayFromZero)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.MultiplyRoundDivideOperator`2">
            <summary>(T.Round(x * power10, digits, mode)) / power10</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.RoundFallbackOperator`1">
            <summary>T.Round(x, digits, mode)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.RoundFallbackOperator`1.#ctor(System.Int32,System.MidpointRounding)">
            <summary>T.Round(x, digits, mode)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ScaleB``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise product of numbers in the specified tensor and their base-radix raised to the specified power.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="n">The value to which base-radix is raised before multipliying x, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ScaleBOperator`1">
            <summary>T.ScaleB(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ScaleBOperator`1.#ctor(System.Int32)">
            <summary>T.ScaleB(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise shifting left of numbers in the specified tensor by the specified shift amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &lt;&lt; <paramref name="shiftAmount"/></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ShiftLeftOperator`1">
            <summary>T &lt;&lt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftLeftOperator`1.#ctor(System.Int32)">
            <summary>T &lt;&lt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmetic``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise arithmetic (signed) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt; <paramref name="shiftAmount"/></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmeticOperator`1">
            <summary>T &gt;&gt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmeticOperator`1.#ctor(System.Int32)">
            <summary>T &gt;&gt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogical``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})">
            <summary>Computes the element-wise logical (unsigned) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt;&gt; <paramref name="shiftAmount"/></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogicalOperator`1">
            <summary>T &gt;&gt;&gt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogicalOperator`1.#ctor(System.Int32)">
            <summary>T &gt;&gt;&gt; amount</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <typeparamref name="T"/>.Exp(-<paramref name="x" />[i]))</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SigmoidOperator`1">
            <summary>1 / (1 + T.Exp(-x))</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sign``1(System.ReadOnlySpan{``0},System.Span{System.Int32})">
            <summary>Computes the element-wise sign of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Sign(<paramref name="x" />[i])</c>.
            If the value is less than 0, the result is -1; if the value is 0, the result is 0; if the value is greater than 0, the result is 1.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SignOperator`1">
            <summary>T.Sign(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sin``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise sine of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Sin(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinOperator`1">
            <summary>T.Sin(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SinCos``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Computes the element-wise sine and cosine of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="sinDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
            <param name="cosDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="sinDestination"/> or <paramref name="cosDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c>(<paramref name="sinDestination" />[i], <paramref name="cosDestination" />[i]) = <typeparamref name="T"/>.SinCos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinCosOperator`1">
            <summary>T.SinCos(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SinCosPi``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})">
            <summary>Computes the element-wise sine and cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="sinPiDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
            <param name="cosPiDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="sinPiDestination"/> or <paramref name="cosPiDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c>(<paramref name="sinPiDestination" />[i], <paramref name="cosPiDestination" />[i]) = <typeparamref name="T"/>.SinCos(<paramref name="x" />[i])</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinCosPiOperator`1">
            <summary>T.SinCosPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sinh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Sinh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>,
            the corresponding destination location is set to that value.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi / 180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinhOperator`1">
            <summary>T.Sinh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SinPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.SinPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SinPiOperator`1">
            <summary>T.SinPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SoftMax``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x" /> must not be empty.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes a sum of <c><typeparamref name="T"/>.Exp(x[i])</c> for all elements in <paramref name="x"/>.
            It then effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sqrt``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise square root of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SqrtOperator`1">
            <summary>T.Sqrt(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.StdDev``1(System.ReadOnlySpan{``0})">
            <summary>Computes the standard deviation of all elements in the specified non-empty tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The standard deviation of all elements in <paramref name="x"/>.</returns>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
            <remarks>
            <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SquaredDifferenceOperator`1">
            <summary>T.RootN(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SquaredDifferenceOperator`1.#ctor(`0)">
            <summary>T.RootN(x, n)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(``0,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a scalar.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> - <paramref name="y" />[i]</c>.
            </para>
            <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the resulting element-wise value is also NaN.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SubtractOperator`1">
            <summary>x - y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Sum``1(System.ReadOnlySpan{``0})">
            <summary>Computes the sum of all elements in the specified tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding all elements in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            If any of the values in the input is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the result is also NaN.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes``1(System.ReadOnlySpan{``0})">
            <summary>Computes the sum of the absolute values of every element in the specified tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the absolute value of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <exception cref="T:System.OverflowException"><typeparamref name="T"/> is a signed integer type and <paramref name="x"/> contained a value equal to <typeparamref name="T"/>'s minimum value.</exception>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                T result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares``1(System.ReadOnlySpan{``0})">
            <summary>Computes the sum of the square of every element in the specified tensor of numbers.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <returns>The result of adding the square of every element in <paramref name="x"/>, or zero if <paramref name="x"/> is empty.</returns>
            <remarks>
            <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                T result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.SquaredOperator`1">
            <summary>x * x</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Tan``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Tan(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanOperator`1">
            <summary>T.Tan(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanOperatorSingle">
            <summary>float.Tan(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanOperatorDouble">
            <summary>double.Tan(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Tanh``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.Tanh(<paramref name="x" />[i])</c>.
            </para>
            <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity"/>, the corresponding destination location is set to -1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity"/>, the corresponding destination location is set to 1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN"/>, the corresponding destination location is set to NaN.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi / 180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanhOperator`1">
            <summary>T.Tanh(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.TanPi``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T"/>.TanPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TanPiOperator`1">
            <summary>T.TanPi(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.TrailingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.TrailingZeroCount(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.TrailingZeroCountOperator`1">
            <summary>T.TrailingZeroCount(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Truncate``1(System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Truncate(<paramref name="x" />[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="y"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" />[i]</c>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a scalar.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="x"/> and <paramref name="destination"/> reference overlapping memory locations and do not begin at the same location.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" /></c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.XorOperator`1">
            <summary>x ^ y</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertToInteger``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> integer type using saturation on overflow.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.ConvertToInteger(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertToIntegerOperator`2">
            <summary>TFrom.ConvertToInteger&lt;TTo&gt;(x)</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorPrimitives.ConvertToIntegerNative``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Copies <paramref name="source"/> to <paramref name="destination"/>, converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> integer type using platform-specific behavior on overflow.
            </summary>
            <param name="source">The source span from which to copy values.</param>
            <param name="destination">The destination span into which the converted values should be written.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
            <remarks>
            <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.ConvertToInteger(<paramref name="source"/>[i])</c>.
            </para>
            </remarks>
        </member>
        <member name="T:System.Numerics.Tensors.TensorPrimitives.ConvertToIntegerNativeOperator`2">
            <summary>TFrom.ConvertToInteger&lt;TTo&gt;(x)</summary>
        </member>
        <member name="T:System.Numerics.Tensors.IReadOnlyTensor">
            <summary>Represents a read-only tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.Item(System.ReadOnlySpan{System.IntPtr})">
            <summary>Gets the specified element of the tensor.</summary>
            <param name="indexes">The index of the element for which to get.</param>
            <returns>The element that exists at <paramref name="indexes" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="indexes" /> does not contain <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" /> elements.
              * <paramref name="indexes" /> contains an element that is negative or greater than or equal to the corresponding dimension length.
            </exception>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.Item(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Item(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.FlattenedLength">
            <summary>Gets the total number of items in the tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.HasAnyDenseDimensions">
            <summary>Gets a value that indicates whether the current tensor has any dimension span where <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsDense" /> is <see langword="true"/>.</summary>
            <value><see langword="true"/> if this tensor has any dense dimensions; otherwise, <see langword="false"/>.</value>
            <remarks>
              <para>This does not include the last dimension, <c>GetDimensionSpan(Rank - 1)</c>, as it always iterates one element at a time and would mean this property always returns <see langword="true"/>.</para>
              <para>An example of a tensor that's not dense but has a dense dimension is a 2x2 Tensor where <c>FlattenedLength: 4; Lengths: [2, 2]; Strides: [4, 1]</c>. In such a scenario, the overall tensor is not dense because the backing storage has a length of at least 6. It has two used elements, two unused elements, followed by the last two used elements. However, the two slices representing <c>[0..1, ..]</c> and <c>[1..2, ..]</c> are dense; thus <c>GetDimension(0).GetSlice(n)</c> will iterate dense tensors: <c>FlattenedLength: 2, Length: [2], Strides: [1]</c>.</para>
            </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.IsDense">
            <summary>Gets a value that indicates whether the current tensor is dense.</summary>
            <value><see langword="true"/> if this tensor is dense; otherwise, <see langword="false"/>.</value>
            <remarks>
              <para>A dense tensor is one where the elements are ordered sequentially in memory and where no gaps exist between the elements.</para>
              <para>For a 2x2 Tensor, this would mean it has <c>FlattenedLength: 4; Lengths: [2, 2]; Strides: [2, 1]</c>. The elements would be sequentially accessed via indexes: <c>[0, 0]; [0, 1]; [1, 0]; [1, 1]</c>.</para>
            </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.IsEmpty">
            <summary>Gets a value indicating whether this tensor is empty.</summary>
            <value><see langword="true"/> if this tensor is empty; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.IsPinned">
            <summary>Gets a value that indicates whether the underlying buffer is pinned.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.Lengths">
            <summary>Gets the length of each dimension in the tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.Rank">
            <summary>Gets the rank, or number of dimensions, in the tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor.Strides">
            <summary>Gets the stride of each dimension in the tensor.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.IReadOnlyTensor`2">
            <summary>Represents a read-only tensor.</summary>
            <typeparam name="TSelf">The type that implements this interface.</typeparam>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor`2.Empty">
            <summary>Gets an empty tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.IntPtr})">
            <summary>Gets a reference to the specified element of the tensor.</summary>
            <param name="indexes">The index of the element for which to get a reference.</param>
            <returns>A reference to the element that exists at <paramref name="indexes" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="indexes" /> does not contain <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" /> elements.
              * <paramref name="indexes" /> contains an element that is negative or greater than or equal to the corresponding dimension length.
            </exception>
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan">
            <summary>Creates a new readonly tensor span over the tensor.</summary>
            <returns>The readonly tensor span representation of the tensor.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new readonly tensor span over a portion of the tensor starting at a specified position to the end of the tensor.</summary>
            <param name="startIndexes">The initial indexes from which the tensor will be converted.</param>
            <returns>The readonly tensor span representation of the tensor.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})">
            <summary>Creates a new readonly tensor span over a portion of the tensor defined by the specified range.</summary>
            <param name="ranges">The ranges of the tensor to convert.</param>
            <returns>The readonly tensor span representation of the tensor.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.CopyTo(System.Numerics.Tensors.TensorSpan{`1}@)">
            <summary>Copies the contents of the tensor into a destination tensor span.</summary>
            <param name="destination">The destination tensor span.</param>
            <exception cref="T:System.ArgumentException"><paramref name="destination" /> is shorter than the source tensor.</exception>
            <remarks>This method copies all of the source tensor to <paramref name="destination" /> even if they overlap.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenTo(System.Span{`1})">
            <summary>Flattens the contents of the tensor into a destination span.</summary>
            <param name="destination">The destination span.</param>
            <exception cref="T:System.ArgumentException"><paramref name="destination" /> is shorter than the source tensor.</exception>
            <remarks>This method copies all of the source tensor to <paramref name="destination" /> even if they overlap.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetDimensionSpan(System.Int32)">
            <summary>Returns a span that can be used to access the flattened elements for a given dimension.</summary>
            <param name="dimension">The dimension for which the span should be created.</param>
            <returns>A span that can be used to access the flattened elements for a given dimension.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetPinnableReference">
            <summary>Returns a reference to an object of type <typeparamref name="T" /> that can be used for pinning.</summary>
            <returns>A reference to the element of the tensor at index 0, or <c>null</c> if the tensor is empty.</returns>
            <remarks>This method is intended to support .NET compilers and is not intended to be called by user code.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)">
            <summary>Return a span that starts at the specified index and contains the specified number of items.</summary>
            <param name="startIndexes">The index at which the span should start.</param>
            <param name="length">The length for the span to return.</param>
            <returns>A span that consists of <paramref name="length" /> elements from the current tensor starting at <paramref name="startIndexes" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <para><paramref name="startIndexes" /> does not contain <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" /> elements.</para>
              -or-
              <para><paramref name="length" /> is negative, greater than <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.FlattenedLength" />, or would cause the span to contain elements that should be skipped due to <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.Strides" />.</para>
            </exception>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="startIndexes" /> is not a valid index into the tensor.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})">
            <summary>Forms a slice out of the current tensor that begins at a specified index.</summary>
            <param name="startIndexes">The indexes at which to begin the slice.</param>
            <returns>A tensor that consists of all elements of the current tensor from <paramref name="startIndexes" /> to the end of the tensor.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndexes" /> is greater than the number of items in the tensor.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})">
            <summary>Gets a slice out of the current tensor that contains a specified range.</summary>
            <param name="ranges">The range of which to slice.</param>
            <returns>A tensor that consists of all elements of the current tensor in <paramref name="ranges" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ranges" /> is larger than the tensor.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.ToDenseTensor">
            <summary>Creates a dense tensor from the elements of the current tensor.</summary>
            <returns>The current tensor if it is already dense; otherwise, a new tensor that contains the elements of this tensor.</returns>
            <remarks>
              <para>A dense tensor is one where the elements are ordered sequentially in memory and where no gaps exist between the elements.</para>
              <para>For a 2x2 Tensor, this would mean it has <c>FlattendLength: 4; Lengths: [2, 2]; Strides: [4, 1]</c>. The elements would be sequentially accessed via indexes: <c>[0, 0]; [0, 1]; [1, 0]; [1, 1]</c>.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryCopyTo(System.Numerics.Tensors.TensorSpan{`1}@)">
            <summary>Attempts to copy the contents of this tensor into a destination tensor span and returns a value to indicate whether or not the operation succeeded.</summary>
            <param name="destination">The target of the copy operation.</param>
            <returns><see langword="true"/> if the copy operation succeeded; otherwise, <c>false</c>.</returns>
            <remarks>
              <para>If the source and <paramref name="destination" /> overlap, the entirety of the source is handled as if it was copied to a temporary location before it is copied to <paramref name="destination" />.</para>
              <para>If the <paramref name="destination" /> length is shorter than the source, no items are copied and the method returns <c>false</c>.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryFlattenTo(System.Span{`1})">
            <summary>Attempts to flatten the contents of this tensor into a destination span and returns a value to indicate whether or not the operation succeeded.</summary>
            <param name="destination">The target of the copy operation.</param>
            <returns><see langword="true"/> if the copy operation succeeded; otherwise, <c>false</c>.</returns>
            <remarks>
              <para>If the source and <paramref name="destination" /> overlap, the entirety of the source is handled as if it was flattened to a temporary location before it is copied to <paramref name="destination" />.</para>
              <para>If the <paramref name="destination" /> length is shorter than the source, no items are copied and the method returns <c>false</c>.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`1}@)">
            <summary>Tries to return a span that starts at the specified index and contains the specified number of items.</summary>
            <param name="startIndexes">The index at which the span should start.</param>
            <param name="length">The desired length of the span to retrieve.</param>
            <param name="span">On successful return, a span that consists of <paramref name="length" /> elements from the current tensor starting at <paramref name="startIndexes" />.</param>
            <returns><c>true</c> if a span was successfully retrieved; otherwise, <c>false</c> which indicates <paramref name="length" /> was invalid.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndexes" /> does not contain <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" /> elements.</exception>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="startIndexes" /> is not a valid index into the tensor.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`1}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.ITensor">
            <summary>Represents a tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.ITensor.Item(System.ReadOnlySpan{System.IntPtr})">
            <summary>Gets or sets the specified element of the tensor.</summary>
            <param name="indexes">The index of the element for which to get.</param>
            <returns>The element that exists at <paramref name="indexes" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="indexes" /> does not contain <see cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" /> elements.
              * <paramref name="indexes" /> contains an element that is negative or greater than or equal to the corresponding dimension length.
            </exception>
        </member>
        <member name="P:System.Numerics.Tensors.ITensor.Item(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="P:System.Numerics.Tensors.ITensor.Item(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.ITensor.IsReadOnly">
            <summary>Gets a value that indicates whether the tensor is read-only.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor.Clear">
            <summary>Clears the contents of the tensor span.</summary>
            <remarks>This method sets the items in the tensor span to their default values. It does not remove items from the tensor span.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor.Fill(System.Object)">
            <summary>Fills the elements of this tensor with a specified value.</summary>
            <param name="value">The value to assign to each element of the tensor.</param>
        </member>
        <member name="T:System.Numerics.Tensors.ITensor`2">
            <summary>Represents a tensor.</summary>
            <typeparam name="TSelf">The type that implements this interface.</typeparam>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.CreateFromShape(System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <summary>Creates a new tensor with the specified lengths.</summary>
            <param name="lengths">The lengths of each dimension.</param>
            <param name="pinned"><see langword="true" /> to pin the underlying buffer. The default is <see langword="false" />.</param>
            <remarks>
              <para>If <paramref name="pinned"/> is true the underlying buffer is created permanently pinned, otherwise the underlying buffer is not pinned.</para>
              <para>The underlying buffer is initialized to default values.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.CreateFromShape(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <summary>Creates a new tensor with the specified lengths and strides.</summary>
            <param name="lengths">The lengths of each dimension.</param>
            <param name="strides">The strides of each dimension.</param>
            <param name="pinned"><see langword="true" /> to pin the underlying buffer. The default is <see langword="false" />.</param>
            <remarks>
              <para>If <paramref name="pinned"/> is true the underlying buffer is created permanently pinned, otherwise the underlying buffer is not pinned.</para>
              <para>The underlying buffer is initialized to default values.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.CreateFromShapeUninitialized(System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <summary>Creates a new tensor with the specified lengths and strides.</summary>
            <param name="lengths">The lengths of each dimension.</param>
            <param name="pinned"><see langword="true" /> to pin the underlying buffer. The default is <see langword="false" />.</param>
            <remarks>
              <para>If <paramref name="pinned"/> is true the underlying buffer is created permanently pinned, otherwise the underlying buffer is not pinned.</para>
              <para>The underlying buffer is not initialized.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.CreateFromShapeUninitialized(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <summary>Creates a new tensor with the specified lengths and strides. If <paramref name="pinned"/> is true the underlying buffer is created permanently pinned, otherwise the underlying buffer is not pinned. The underlying buffer is not initialized.</summary>
            <param name="lengths">The lengths of each dimension.</param>
            <param name="strides">The strides of each dimension.</param>
            <param name="pinned"><see langword="true" /> to pin the underlying buffer. The default is <see langword="false" />.</param>
            <remarks>
              If <paramref name="pinned"/> is true the underlying buffer is created permanently pinned, otherwise the underlying buffer is not pinned.
            The underlying buffer is not initialized.
            </remarks>
        </member>
        <member name="P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NRange})">
            <summary>Gets or sets a slice out of the current tensor that contains a specified range.</summary>
            <param name="ranges">The range of which to slice.</param>
            <returns>A tensor that consists of all elements of the current tensor in <paramref name="ranges" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ranges" /> is larger than the tensor.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan">
            <summary>Creates a new tensor span over the tensor.</summary>
            <returns>The tensor span representation of the tensor.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor span over a portion of the tensor starting at a specified position to the end of the tensor.</summary>
            <param name="startIndexes">The initial indexes from which the tensor will be converted.</param>
            <returns>The tensor span representation of the tensor.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})">
            <summary>Creates a new tensor span over a portion of the tensor defined by the specified range.</summary>
            <param name="ranges">The ranges of the tensor to convert.</param>
            <returns>The tensor span representation of the tensor.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.Fill(`1)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor.Fill(System.Object)" />
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.GetDimensionSpan(System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetDimensionSpan(System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.GetPinnableReference">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetPinnableReference" />
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.Span{`1}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.ITensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.Span{`1}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1">
            <summary>Represents the slices that exist within a dimension of a tensor span.</summary>
            <typeparam name="T">The type of the elements within the tensor span.</typeparam>
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.IsDense">
            <summary>Gets <c>true</c> if the slices that exist within the tracked dimension are dense; otherwise, <c>false</c>.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.Length">
            <summary>Gets the length of the tensor dimension span.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.Item(System.IntPtr)">
            <summary>Gets the tensor span representing a slice of the tracked dimension using the specified index.</summary>
            <param name="index">The index of the tensor span slice to retrieve within the tracked dimension.</param>
            <returns>The tensor span representing a slice of the tracked dimension using <paramref name="index" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.GetEnumerator">
            <summary>Gets an enumerator for the readonly tensor dimension span.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.Enumerator">
            <summary>Enumerates the spans of a tensor dimension span.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.Enumerator.Current">
            <summary>Gets the span at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the tensor span.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1.Enumerator.Reset">
            <summary>Sets the enumerator to its initial position, which is before the first element in the tensor span.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1">
            <summary>
            Represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type-safe and memory-safe.
            </summary>
            <typeparam name="T">The type of the elements within the tensor span.</typeparam>
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Empty">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Empty" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[])">
            <summary>Creates a new tensor over the entirety of the target array.</summary>
            <param name="array">The target array.</param>
            <remarks>
              <para>Returns default when <paramref name="array"/> is null.</para>
              <para>The created tensor span has a single dimension that is the same length as <paramref name="array" />.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor over the portion of the target array using the specified lengths.</summary>
            <param name="array">The target array.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor will have a single dimension that is the same length as <paramref name="array" />.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="array" /> is null and <paramref name="lengths" /> is not empty.
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="array" />.Length.
            </exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor over the portion of the target array beginning at the specified start index and using the specified lengths and strides.</summary>
            <param name="array">The target array.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor will have a single dimension that is the same length as <paramref name="array" />.</param>
            <param name="strides">The strides of each dimension. If an empty span is provided, then strides will be automatically calculated from <paramref name="lengths" />.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="array" /> is null and <paramref name="lengths" /> or <paramref name="strides" /> is not empty.
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="array" />.Length.
              * <paramref name="strides" /> is not empty and has a length different from <paramref name="lengths"/>.
              * <paramref name="strides" /> is not empty and contains an element that is negative.
              * <paramref name="strides" /> is not empty and contains an element that is zero in a non leading position.
            </exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor over the portion of the target array beginning at the specified start index and using the specified lengths and strides.</summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the tensor.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor will have a single dimension that is the same length as <paramref name="array" />.</param>
            <param name="strides">The strides of each dimension. If an empty span is provided, then strides will be automatically calculated from <paramref name="lengths" />.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="array" /> is null and <paramref name="lengths" /> or <paramref name="strides" /> is not empty.
              * <paramref name="start" /> is not in range of <paramref name="array" />.
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="array" />.Length.
              * <paramref name="strides" /> is not empty and has a length different from <paramref name="lengths"/>.
              * <paramref name="strides" /> is not empty and contains an element that is negative.
              * <paramref name="strides" /> is not empty and contains an element that is zero in a non leading position.
            </exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>Creates a new tensor span over the entirety of the target span.</summary>
            <param name="span">The target span.</param>
            <remarks>The created tensor span has a single dimension that is the same length as <paramref name="span" />.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor span over the target span using the specified lengths.</summary>
            <param name="span">The target span.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor span will have a single dimension that is the same length as <paramref name="span" />.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="span" />.Length.
            </exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor span over the target span using the specified lengths and strides.</summary>
            <param name="span">The target span.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor span will have a single dimension that is the same length as <paramref name="span" />.</param>
            <param name="strides">The strides of each dimension. If an empty span is provided, then strides will be automatically calculated from <paramref name="lengths" />.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="span" />.Length.
              * <paramref name="strides" /> is not empty and has a length different from <paramref name="lengths"/>.
              * <paramref name="strides" /> is not empty and contains an element that is negative.
              * <paramref name="strides" /> is not empty and contains an element that is zero in a non leading position.
            </exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.Array)">
            <summary>Creates a new tensor span over the entirety of the target array.</summary>
            <param name="array">The target array.</param>
            <remarks>
              <para>Returns default when <paramref name="array"/> is null.</para>
              <para>The created tensor span has a single dimension that is the same length as <paramref name="array" />.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.Array,System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor span over the portion of the target array beginning at the specified start index and using the specified lengths and strides.</summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the tensor span.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor span will have a single dimension that is the same length as <paramref name="array" />.</param>
            <param name="strides">The strides of each dimension. If an empty span is provided, then strides will be automatically calculated from <paramref name="lengths" />.</param>
            <remarks>
              <para>Returns default when <paramref name="array"/> is null.</para>
              <para></para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="array" /> is null and <paramref name="lengths" /> or <paramref name="strides" /> is not empty.
              * <paramref name="start" /> is not in range of <paramref name="array" />.
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="array" />.Length.
              * <paramref name="strides" /> is not empty and has a length different from <paramref name="lengths"/>.
              * <paramref name="strides" /> is not empty and contains an element that is negative.
              * <paramref name="strides" /> is not empty and contains an element that is zero in a non leading position.
            </exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr)">
            <summary>Creates a new tensor span over the target unmanaged buffer.</summary>
            <param name="data">The pointer to the start of the target unmanaged buffer.</param>
            <param name="dataLength">The number of elements the target unmanaged buffer contains.</param>
            <remarks>Returns default when <paramref name="data" /> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="data" /> is <c>null</c> and <paramref name="dataLength" /> is not zero</exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor span over the target unmanaged buffer using the specified lengths.</summary>
            <param name="data">The pointer to the start of the target unmanaged buffer.</param>
            <param name="dataLength">The number of elements the target unmanaged buffer contains.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor span will have a single dimension that is the same length as <paramref name="dataLength" />.</param>
            <remarks>Returns default when <paramref name="data" /> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="data" /> is <c>null</c> and <paramref name="dataLength" /> is not zero.
              * <paramref name="data" /> is null and <paramref name="lengths" />.
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="dataLength" />.
            </exception>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a new tensor span over the target unmanaged buffer using the specified lengths and strides.</summary>
            <param name="data">The pointer to the start of the target unmanaged buffer.</param>
            <param name="dataLength">The number of elements the target unmanaged buffer contains.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor span will have a single dimension that is the same length as <paramref name="dataLength" />.</param>
            <param name="strides">The strides of each dimension. If an empty span is provided, then strides will be automatically calculated from <paramref name="lengths" />.</param>
            <remarks>Returns default when <paramref name="data" /> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
              One of the following conditions is met:
              * <paramref name="data" /> is <c>null</c> and <paramref name="dataLength" /> is not zero.
              * <paramref name="data" /> is null and <paramref name="lengths" /> or <paramref name="strides" /> is not empty.
              * <paramref name="lengths" /> is not empty and contains an element that is either zero or negative.
              * <paramref name="lengths" /> is not empty and has a flattened length greater than <paramref name="dataLength" />.
              * <paramref name="strides" /> is not empty and has a length different from <paramref name="lengths"/>.
              * <paramref name="strides" /> is not empty and contains an element that is negative.
              * <paramref name="strides" /> is not empty and contains an element that is zero in a non leading position.
            </exception>
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Item(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.FlattenedLength">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.FlattenedLength" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.HasAnyDenseDimensions">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.HasAnyDenseDimensions" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.IsDense">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsDense" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.IsEmpty">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsEmpty" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.IsPinned">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsPinned" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Lengths">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Lengths" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Rank">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" />
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Strides">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Strides" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Equality(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Returns a value that indicates whether two tensor spans are equal.</summary>
            <param name="left">The first tensor span to compare.</param>
            <param name="right">The second tensor span to compare.</param>
            <returns><c>true</c> if the two tensor span are equal; otherwise, <c>false</c>.</returns>
            <remarks>Two tensor span are equal if they have the same length and the corresponding elements of <paramref name="left" /> and <paramref name="right" /> point to the same memory. Note that the test for equality does not attempt to determine whether the contents are equal.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Inequality(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Returns a value that indicates whether two tensor spans are not equal.</summary>
            <param name="left">The first tensor span to compare.</param>
            <param name="right">The second tensor span to compare.</param>
            <returns><c>true</c> if the two tensor span are not equal; otherwise, <c>false</c>.</returns>
            <remarks>Two tensor span are not equal if they have the different lengths or if the corresponding elements of <paramref name="left" /> and <paramref name="right" /> do not point to the same memory. Note that the test for equality does not attempt to determine whether the contents are not equal.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Implicit(`0[])~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}">
            <summary>Defines an implicit conversion of an array to a readonly tensor span.</summary>
            <param name="array">The array to convert to a readonly tensor span.</param>
            <returns>The readonly tensor span that corresponds to <paramref name="array" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.CastUp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Casts a tensor span of <typeparamref name="TDerived" /> to a tensor span of <typeparamref name="T" />.</summary>
            <typeparam name="TDerived">The element type of the source tensor span, which must be derived from <typeparamref name="T" />.</typeparam>
            <param name="items">The source tensor span. No copy is made.</param>
            <returns>A tensor span with elements cast to the new type.</returns>
            <remarks>This method uses a covariant cast, producing a tensor span that shares the same memory as the source. The relationships expressed in the type constraints ensure that the cast is a safe operation.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.CopyTo(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.CopyTo(System.Numerics.Tensors.TensorSpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Equals(System.Object)">
            <summary>Calls to this method are not supported.</summary>
            <param name="obj">Not supported.</param>
            <returns>Calls to this method are not supported.</returns>
            <exception cref="T:System.NotSupportedException">Calls to this method are not supported.</exception>
            <remarks>This method is not supported as tensor spans cannot be boxed. To compare two tensor spans, use operator ==.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.FlattenTo(System.Span{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenTo(System.Span{`1})" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetDimensionSpan(System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetDimensionSpan(System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetEnumerator">
            <summary>Gets an enumerator for the readonly tensor span.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetHashCode">
            <summary>Calls to this method are not supported.</summary>
            <returns>Calls to this method are not supported.</returns>
            <exception cref="T:System.NotSupportedException">Calls to this method are not supported.</exception>
            <remarks>This method is not supported as tensor spans cannot be boxed.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetPinnableReference">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetPinnableReference" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Slice(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.ToString">
            <summary>Returns the string representation of the tensor.</summary>
            <returns>The string representation of the tensor.</returns>
            <remarks>This API only lists the shape of the tensor, it does not include the contents.</remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.ToString(System.ReadOnlySpan{System.IntPtr})">
            <summary>Creates a <see cref="T:System.String"/> representation of the tensor.</summary>
            <param name="maximumLengths">The maximum number of elements to print for each dimension of the tensor.</param>
            <returns>A <see cref="T:System.String"/> representation of the tensor.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumLengths" /> is not empty and does not contain <see cref="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Rank" /> elements.</exception>
            <remarks>
              <para>No contents will be printed if <paramref name="maximumLengths" /> is empty.</para>
              <para>If a given dimension contains more elements then the corresponding limit specified by <paramref name="maximumLengths" />, remaining elements will be represented by <c>..</c>.</para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.TryCopyTo(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryCopyTo(System.Numerics.Tensors.TensorSpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.TryFlattenTo(System.Span{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryFlattenTo(System.Span{`1})" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Enumerator">
            <summary>Enumerates the elements of a tensor span.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the tensor span.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Enumerator.Reset">
            <summary>Sets the enumerator to its initial position, which is before the first element in the tensor span.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor">
            <summary>Provides methods for tensor operations.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan``1(``0[])">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[])" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan``1(``0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsTensorSpan``1(``0[])">
            <inheritdoc cref="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[])" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsTensorSpan``1(``0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Broadcast the data from <paramref name="source"/> to the smallest broadcastable shape compatible with <paramref name="lengthsSource"/>. Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> and allocates new memory.
            </summary>
            <param name="source">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="lengthsSource">Other <see cref="T:System.Numerics.Tensors.Tensor`1"/> to make shapes broadcastable.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})">
            <summary>
            Broadcast the data from <paramref name="source"/> to the new shape <paramref name="lengths"/>. Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> and allocates new memory.
            If the shape of the <paramref name="source"/> is not compatible with the new shape, an exception is thrown.
            </summary>
            <param name="source">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="lengths"><see cref="T:System.ReadOnlySpan`1"/> of the desired new shape.</param>
            <exception cref="T:System.ArgumentException">The shapes are not broadcast compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Broadcast the data from <paramref name="source"/> to <paramref name="destination"/>.
            </summary>
            <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Broadcast the data from <paramref name="source"/> to <paramref name="destination"/>.
            </summary>
            <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination">Other <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to make shapes broadcastable.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Broadcast the data from <paramref name="source"/> to <paramref name="destination"/>.
            </summary>
            <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Concatenate``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})">
            <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
            <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConcatenateOnDimension``1(System.Int32,System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})">
            <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
            <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
            <param name="dimension">The axis along which the tensors will be joined. If axis is -1, arrays are flattened before use. Default is 0.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Concatenate``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
            <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConcatenateOnDimension``1(System.Int32,System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
            <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
            <param name="dimension">The axis along which the tensors will be joined. If axis is -1, arrays are flattened before use. Default is 0.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Create``1(``0[])">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[])" />
            <returns>A new tensor that uses <paramref name="array" /> as its backing buffer.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr})" />
            <returns>A new tensor that uses <paramref name="array" /> as its backing buffer and with the specified <paramref name="lengths" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
            <returns>A new tensor that uses <paramref name="array" /> as its backing buffer and with the specified <paramref name="lengths" /> and <paramref name="strides"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
            <returns>A new tensor that uses <paramref name="array" /> as its backing buffer and with the specified <paramref name="lengths" /> and <paramref name="strides" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CreateFromShape``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.CreateFromShape(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
            <returns>A new tensor with the specified lengths.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CreateFromShape``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.CreateFromShape(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
            <returns>A new tensor with the specified <paramref name="lengths" /> and <paramref name="strides" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CreateFromShapeUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.CreateFromShapeUninitialized(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CreateFromShapeUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.CreateFromShapeUninitialized(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.FillGaussianNormalDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Random)">
            <summary>
            Fills the given <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with random data in a Gaussian normal distribution. <see cref="T:System.Random"/>
            can optionally be provided for seeding.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="destination">The destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the data will be stored.</param>
            <param name="random"><see cref="T:System.Random"/> to provide random seeding. Defaults to <see cref="P:System.Random.Shared"/> if not provided.</param>
            <returns></returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.FillUniformDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Random)">
            <summary>
            Fills the given <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with random data in a uniform distribution. <see cref="T:System.Random"/>
            can optionally be provided for seeding.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="destination">The destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the data will be stored.</param>
            <param name="random"><see cref="T:System.Random"/> to provide random seeding. Defaults to <see cref="P:System.Random.Shared"/> if not provided.</param>
            <returns></returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="destination"></param>
            <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second value to compare.</param>
            <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second value to compare.</param>
            <param name="destination"></param>
            <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> where the value is true if the elements are equal and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.EqualsAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are equal to <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are eqaul to <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are equal to <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.EqualsAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are equal to <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are eqaul to <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are equal to <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.EqualsAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are equal to <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are equal to <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are equal to <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.EqualsAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are equal to <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are equal to <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are equal to <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,``0)">
            <summary>
            Updates the <paramref name="tensor"/> tensor with the <paramref name="value"/> where the <paramref name="filter"/> is true.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="filter">Input filter where if the index is true then it will update the <paramref name="tensor"/>.</param>
            <param name="value">Value to update in the <paramref name="tensor"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Updates the <paramref name="tensor"/> tensor with the <paramref name="values"/> where the <paramref name="filter"/> is true.
            If dimensions are not the same an exception is thrown.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="filter">Input filter where if the index is true then it will update the <paramref name="tensor"/>.</param>
            <param name="values">Values to update in the <paramref name="tensor"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="destination"></param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements are greater than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements are greater than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares <paramref name="x"/> to see which elements are greater than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares <paramref name="x"/> to see which elements are greater than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="y"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="y"/> are greater than <paramref name="x"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are greater than <paramref name="x"/>.
            </summary>
            <param name="y">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="x">Value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are greater than <paramref name="x"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are greater than or equal to <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are greater than or equal to <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="destination"></param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements are greater than or equal to <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements are greater than or equal to <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares <paramref name="x"/> to see which elements are greater than or equal to <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares <paramref name="x"/> to see which elements are greater than or equal to <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are greater than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="y"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are greater than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="y"/> are greater than <paramref name="x"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are greater than <paramref name="x"/>.
            </summary>
            <param name="y">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="x">Value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are greater than <paramref name="x"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="destination"></param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="y"/> are less than <paramref name="x"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are less than <paramref name="x"/>.
            </summary>
            <param name="y">First value to compare.</param>
            <param name="x">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are less than <paramref name="x"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="y"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First value to compare.</param>
            <param name="y">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see which elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="destination"></param>
            <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/> and
            false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)">
            <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1"/> to see which elements are less than <paramref name="y"/>.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not."/>
            </summary>
            <param name="x"><see cref="T:System.Numerics.Tensors.Tensor`1"/> to compare.</param>
            <param name="y"><typeparamref name="T"/> to compare against <paramref name="x"/>.</param>
            <param name="destination"></param>
            <returns><see cref="T:System.Numerics.Tensors.Tensor`1"/> where the value is true if the elements in <paramref name="x"/> are less than <paramref name="y"/>
            and false if they are not.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if all elements of <paramref name="y"/> are less than <paramref name="x"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are less than <paramref name="x"/>.
            </summary>
            <param name="y">First value to compare.</param>
            <param name="x">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if all elements in <paramref name="y"/> are less than <paramref name="x"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="x"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to compare.</param>
            <param name="y">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="x"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to see if any elements of <paramref name="y"/> are less than <paramref name="y"/>.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are less than <paramref name="y"/>.
            </summary>
            <param name="x">First value to compare.</param>
            <param name="y">Second value to compare against.</param>
            <returns><see cref="T:System.Boolean"/> where the value is true if any elements in <paramref name="y"/> are less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.PermuteDimensions``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.Int32})">
            <summary>
            Swaps the dimensions of the <paramref name="tensor"/> tensor according to the <paramref name="dimensions"/> parameter.
            If <paramref name="tensor"/> is a 1D tensor, it will return <paramref name="tensor"/>. Otherwise it creates a new <see cref="T:System.Numerics.Tensors.Tensor`1"/>
            with the new axis ordering by allocating new memory.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/></param>
            <param name="dimensions"><see cref="T:System.ReadOnlySpan`1"/> with the new axis ordering.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})">
            <summary>
            Reshapes the <paramref name="tensor"/> tensor to the specified <paramref name="lengths"/>. If one of the lengths is -1, it will be calculated automatically.
            Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape,
            an exception is thrown.
            </summary>
            <param name="tensor"><see cref="T:System.Numerics.Tensors.Tensor`1"/> you want to reshape.</param>
            <param name="lengths"><see cref="T:System.ReadOnlySpan`1"/> with the new dimensions.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.TensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})">
            <summary>
            Reshapes the <paramref name="tensor"/> tensor to the specified <paramref name="lengths"/>. If one of the lengths is -1, it will be calculated automatically.
            Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape,
            an exception is thrown.
            </summary>
            <param name="tensor"><see cref="T:System.Numerics.Tensors.TensorSpan`1"/> you want to reshape.</param>
            <param name="lengths"><see cref="T:System.ReadOnlySpan`1"/> with the new dimensions.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})">
            <summary>
            Reshapes the <paramref name="tensor"/> tensor to the specified <paramref name="lengths"/>. If one of the lengths is -1, it will be calculated automatically.
            Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape,
            an exception is thrown.
            </summary>
            <param name="tensor"><see cref="T:System.Numerics.Tensors.TensorSpan`1"/> you want to reshape.</param>
            <param name="lengths"><see cref="T:System.ReadOnlySpan`1"/> with the new dimensions.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})">
            <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1"/>, allocates new memory, and copies the data from <paramref name="tensor"/>. If the final shape is smaller all data after
            that point is ignored.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="lengths"><see cref="T:System.ReadOnlySpan`1"/> of the desired new shape.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ResizeTo``1(System.Numerics.Tensors.Tensor{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Copies the data from <paramref name="tensor"/>. If the final shape is smaller all data after that point is ignored.
            If the final shape is bigger it is filled with 0s.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the desired new shape.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ResizeTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Copies the data from <paramref name="tensor"/>. If the final shape is smaller all data after that point is ignored.
            If the final shape is bigger it is filled with 0s.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the desired new shape.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ResizeTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Copies the data from <paramref name="tensor"/>. If the final shape is smaller all data after that point is ignored.
            If the final shape is bigger it is filled with 0s.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the desired new shape.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Reverse the order of elements in the <paramref name="tensor"/>. The shape of the tensor is preserved, but the elements are reordered.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ReverseDimension``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>
            Reverse the order of elements in the <paramref name="tensor"/> along the given dimension. The shape of the tensor is preserved, but the elements are reordered.
            <paramref name="dimension"/> defaults to -1 when not provided, which reverses the entire tensor.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="dimension">dimension along which to reverse over. -1 will reverse over all of the dimensions of the left tensor.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Reverse the order of elements in the <paramref name="tensor"/>. The shape of the tensor is preserved, but the elements are reordered.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ReverseDimension``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <summary>
            Reverse the order of elements in the <paramref name="tensor"/> along the given axis. The shape of the tensor is preserved, but the elements are reordered.
            <paramref name="dimension"/> defaults to -1 when not provided, which reverses the entire span.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination"></param>
            <param name="dimension">dimension along which to reverse over. -1 will reverse over all of the dimensions of the left tensor.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SequenceEqual``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SequenceEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})">
            <summary>
            Sets a slice of the given <paramref name="tensor"/> with the provided <paramref name="values"/> for the given <paramref name="ranges"/>
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="values">The values you want to set in the <paramref name="tensor"/>.</param>
            <param name="ranges">The ranges you want to set.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})">
            <summary>
            Sets a slice of the given <paramref name="tensor"/> with the provided <paramref name="values"/> for the given <paramref name="ranges"/>
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="values">The values you want to set in the <paramref name="tensor"/>.</param>
            <param name="ranges">The ranges you want to set.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Split``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.IntPtr)">
            <summary>
            Split a <see cref="T:System.Numerics.Tensors.Tensor`1"/> into <paramref name="splitCount"/> along the given <paramref name="dimension"/>. If the tensor cannot be split
            evenly on the given <paramref name="dimension"/> an exception is thrown.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="splitCount">How many times to split the <paramref name="tensor"/></param>
            <param name="dimension">The axis to split on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.Tensor{``0})">
            <summary>
            Removes all dimensions of length one from the <paramref name="tensor"/>.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.Tensor`1"/> to remove all dimensions of length 1.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SqueezeDimension``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <summary>
            Removes axis of length one from the <paramref name="tensor"/> for the given <paramref name="dimension"/>.
            If the dimension is not of length one it will throw an exception.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.Tensor`1"/> to remove dimension of length 1.</param>
            <param name="dimension">The dimension to remove.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Removes all dimensions of length one from the <paramref name="tensor"/>.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to remove all dimensions of length 1.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SqueezeDimension``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <summary>
            Removes axis of length one from the <paramref name="tensor"/> for the given <paramref name="dimension"/>.
            If the dimension is not of length one it will throw an exception.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to remove dimension of length 1.</param>
            <param name="dimension">The dimension to remove.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Removes all dimensions of length one from the <paramref name="tensor"/>.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to remove all dimensions of length 1.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SqueezeDimension``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>
            Removes axis of length one from the <paramref name="tensor"/> for the given <paramref name="dimension"/>.
            If the dimension is not of length one it will throw an exception.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to remove dimension of length 1.</param>
            <param name="dimension">The dimension to remove.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Stack``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})">
            <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1"/> along a new dimension that is added at position 0. All tensors must have the same shape.
            </summary>
            <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.StackAlongDimension``1(System.Int32,System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})">
            <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1"/> along a new dimension. The axis parameter specifies the index of the new dimension. All tensors must have the same shape.
            </summary>
            <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="dimension">Index of where the new dimension will be.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Stack``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1"/> along a new dimension that is added at position 0. All tensors must have the same shape.
            </summary>
            <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.StackAlongDimension``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1"/> along a new dimension. The axis parameter specifies the index of the new dimension. All tensors must have the same shape.
            </summary>
            <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="destination"></param>
            <param name="dimension">Index of where the new dimension will be.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Transpose``1(System.Numerics.Tensors.Tensor{``0})">
            <summary>
            Swaps the last two dimensions of the <paramref name="tensor"/> tensor.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Broadcast the data from <paramref name="tensor"/> to the smallest broadcastable shape compatible with <paramref name="destination"/> and stores it in <paramref name="destination"/>
            If the shapes are not compatible, false is returned.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1"/>.</param>
            <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Broadcast the data from <paramref name="tensor"/> to the smallest broadcastable shape compatible with <paramref name="destination"/> and stores it in <paramref name="destination"/>
            If the shapes are not compatible, false is returned.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Broadcast the data from <paramref name="tensor"/> to the smallest broadcastable shape compatible with <paramref name="destination"/> and stores it in <paramref name="destination"/>
            If the shapes are not compatible, false is returned.
            </summary>
            <param name="tensor">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <summary>
            Insert a new dimension of length 1 that will appear at the dimension position.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.Tensor`1"/> to add a dimension of length 1.</param>
            <param name="dimension">The index of the dimension to add.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <summary>
            Insert a new dimension of length 1 that will appear at the dimension position.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to add a dimension of length 1.</param>
            <param name="dimension">The index of the dimension to add.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>
            Insert a new dimension of length 1 that will appear at the dimension position.
            </summary>
            <param name="tensor">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to add a dimension of length 1.</param>
            <param name="dimension">The index of the dimension to add.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the absolute value of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the abs of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the absolute value of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to take the abs of.</param>
            <param name="destination">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> destination.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse cosine of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse cosine of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic cosine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic cosine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic sine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic sine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic sine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic sine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic tangent divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The input<see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the inverse hyperbolic tangent divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The input<see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Average``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Returns the average of the elements in the <paramref name="x"/> tensor.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to take the mean of.</param>
            <returns><typeparamref name="T"/> representing the mean.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise cube root of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise cube root of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise ceiling of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise ceiling of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Copies <paramref name="source"/> to a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)">
            <summary>
            Copies <paramref name="source"/> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Copies <paramref name="source"/> to a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)">
            <summary>
            Copies <paramref name="source"/> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Copies <paramref name="source"/> to a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)">
            <summary>
            Copies <paramref name="source"/> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> converting each <typeparamref name="TFrom"/>
            value to a <typeparamref name="TTo"/> value.
            </summary>
            <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new tensor with the result.
            </summary>
            <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="sign">The number with the associated sign.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="sign">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> with the associated signs.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new tensor with the result.
            </summary>
            <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="sign">The number with the associated sign.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="sign">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> with the associated signs.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the cosine of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the cosine of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the cosine of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the cosine of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CosineSimilarity``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Compute cosine similarity between <paramref name="x"/> and <paramref name="y"/>.
            </summary>
            <param name="x">The first <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <param name="y">The second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the results.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <remarks>
            <para>
            This method effectively computes <c><typeparamref name="T"/>.CosPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the results.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <param name="destination"></param>
            <remarks>
            <para>
            This method effectively computes <c><typeparamref name="T"/>.CosPi(<paramref name="x" />[i])</c>.
            </para>
            <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)"/> or multiply by <typeparamref name="T"/>.Pi/180 to convert degrees to radians.
            </para>
            <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
            </remarks>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise conversion of each number of degrees in the specified tensor to radians and returns a new tensor with the results.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise conversion of each number of degrees in the specified tensor to radians and returns a new tensor with the results.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Distance``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the distance between two points, specified as non-empty, equal-length tensors of numbers, in Euclidean space.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Dot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the dot product of two tensors containing numbers.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise result of raising 10 to the number powers in the specified tensor.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise result of raising 10 to the number powers in the specified tensor.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            </summary>
            <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            </summary>
            <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
            <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Int32}@)">
            <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.IndexOfMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the index of the largest number in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the index of the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.IndexOfMin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the index of the smallest number in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.IndexOfMinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Searches for the index of the number with the smallest magnitude in the specified tensor.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Computes the element-wise leading zero count of numbers in the specified tensor.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Computes the element-wise leading zero count of numbers in the specified tensor.
            </summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the natural logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the natural logarithm of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the natural logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the natural logarithm of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor</param>
            <param name="y">The second tensor</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor</param>
            <param name="y">The second tensor</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor</param>
            <param name="y">The second tensor</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
            <param name="x">The first tensor</param>
            <param name="y">The second tensor</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the base 10 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 10 logarithm of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the base 10 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 10 logarithm of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the base 10 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 10 logarithm of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the base 10 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 10 logarithm of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the base 2 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 2 logarithm of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the base 2 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 2 logarithm of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the base 2 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 2 logarithm of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the base 2 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the base 2 logarithm of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the natural logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the natural logarithm of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the natural logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the natural logarithm of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the largest number in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the largest number in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the smallest number in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Searches for the smallest number in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
            <param name="x">The first tensor, represented as a span.</param>
            <param name="y">The second tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
             Takes the norm of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the norm of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
            <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The second input</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Pow``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The second input</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Pow``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Product``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the product of all elements in the specified non-empty tensor of numbers.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RootN``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="n">The degree of the root to be computed, represented as a scalar.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RootN``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
            <param name="x">The tensor, represented as a span.</param>
            <param name="destination">The destination tensor, represented as a span.</param>
            <param name="n">The degree of the root to be computed, represented as a scalar.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RotateLeft``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RotateLeft``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <param name="destination"></param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RotateRight``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.RotateRight``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
            <param name="x">The tensor</param>
            <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
            <param name="destination"></param>
            <exception cref="T:System.ArgumentException">Destination is too short.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.MidpointRounding)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="digits"></param>
            <param name="mode"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.MidpointRounding,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="digits"></param>
            <param name="mode"></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="digits"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="digits"></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.MidpointRounding)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="mode"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.MidpointRounding,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="mode"></param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Takes the square root of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the square root of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>
            Takes the square root of each element of the <paramref name="x"/> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> with the result.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the square root of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.StdDev``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Returns the standard deviation of the elements in the <paramref name="x"/> tensor.
            </summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1"/> to take the standard deviation of.</param>
            <returns><typeparamref name="T"/> representing the standard deviation.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Sums the elements of the specified tensor.
            </summary>
            <param name="x">Tensor to sum</param>
            <returns></returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.SumOfSquares``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>
            Sums the squared elements of the specified tensor.
            </summary>
            <param name="x">Tensor to sum squares of</param>
            <returns></returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
            <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/> to take the sin of.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
            <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1"/>.</param>
            <param name="destination"></param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs element-wise addition between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to add with <paramref name="y" />.</param>
            <param name="y">The tensor to add with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> + <paramref name="y" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="y" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Performs element-wise addition between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to add with <paramref name="y" />.</param>
            <param name="y">The scalar to add with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> + <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise addition between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to add with <paramref name="y" />.</param>
            <param name="y">The tensor to add with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> + <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" />, <paramref name="y" />, and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise addition between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to add with <paramref name="y" />.</param>
            <param name="y">The scalar to add with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> + <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C73EBF61CD0A1187D8FDBF1BBD2D8347`1.op_Addition(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C73EBF61CD0A1187D8FDBF1BBD2D8347`1.op_Addition(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C73EBF61CD0A1187D8FDBF1BBD2D8347`1.op_Addition(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_Addition(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_Addition(System.Numerics.Tensors.Tensor{`0},`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(``0,System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_Addition(`0,System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_AdditionAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_AdditionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_AdditionAssignment``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_AdditionAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_Addition(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_Addition(System.Numerics.Tensors.TensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Addition``1(``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_Addition(`0,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_AdditionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_AdditionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_AdditionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_AdditionAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs bitwise-and between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-and with <paramref name="y" />.</param>
            <param name="y">The tensor to bitwise-and with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> &amp; <paramref name="y" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="y" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Performs bitwise-and between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-and with <paramref name="y" />.</param>
            <param name="y">The scalar to bitwise-and with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> &amp; <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs bitwise-and between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-and with <paramref name="y" />.</param>
            <param name="y">The tensor to bitwise-and with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> &amp; <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" />, <paramref name="y" />, and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs bitwise-and between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-and with <paramref name="y" />.</param>
            <param name="y">The scalar to bitwise-and with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> &amp; <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseAnd(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseAnd(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseAnd(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAnd(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAnd(System.Numerics.Tensors.Tensor{`0},`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(``0,System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAnd(`0,System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAndAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAndAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAndAssignment``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAndAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAnd(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAnd(System.Numerics.Tensors.TensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAnd(`0,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAndAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAndAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseAndAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAndAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs bitwise-or between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-or with <paramref name="y" />.</param>
            <param name="y">The tensor to bitwise-or with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> | <paramref name="y" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="y" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Performs bitwise-or between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-or with <paramref name="y" />.</param>
            <param name="y">The scalar to bitwise-or with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> | <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs bitwise-or between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-or with <paramref name="y" />.</param>
            <param name="y">The tensor to bitwise-or with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> | <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" />, <paramref name="y" />, and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs bitwise-or between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to bitwise-or with <paramref name="y" />.</param>
            <param name="y">The scalar to bitwise-or with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> | <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseOr(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOr(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOr(System.Numerics.Tensors.Tensor{`0},`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(``0,System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOr(`0,System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOrAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOrAssignment``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOrAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOr(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOr(System.Numerics.Tensors.TensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOr(`0,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_BitwiseOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOrAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Decrement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs an decrement on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to decrement.</param>
            <returns>A new tensor containing the result of --<paramref name="x" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Decrement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs an decrement on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to decrement.</param>
            <param name="destination">The destination where the result of --<paramref name="x" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_DecrementAssignment``1(System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$F3C6A6407EFD24140A9D94B397075922`1.op_DecrementAssignment"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_DecrementAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$6825342FD39A3FDA3F46942F60CE3B4C`1.op_DecrementAssignment"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs element-wise division between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor dividend.</param>
            <param name="y">The tensor divisor.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> / <paramref name="y" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="y" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Performs element-wise division between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor dividend.</param>
            <param name="y">The scalar divisor.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> / <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs element-wise division between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The scalar dividend.</param>
            <param name="y">The tensor divisor.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> / <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise division between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor dividend.</param>
            <param name="y">The tensor divisor.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> / <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" />, <paramref name="y" />, and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise division between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor dividend.</param>
            <param name="y">The scalar divisor.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> / <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise division between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The scalar dividend.</param>
            <param name="y">The tensor divisor.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> / <paramref name="y" /> is written.</param>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="y" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$11ECEC3835A71DB7BDDB2EA6F4E3B0EA`1.op_Division(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$11ECEC3835A71DB7BDDB2EA6F4E3B0EA`1.op_Division(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$11ECEC3835A71DB7BDDB2EA6F4E3B0EA`1.op_Division(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_Division(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_Division(System.Numerics.Tensors.Tensor{`0},`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(``0,System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_Division(`0,System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_DivisionAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_DivisionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_DivisionAssignment``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_DivisionAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_Division(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_Division(System.Numerics.Tensors.TensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Division``1(``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_Division(`0,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_DivisionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_DivisionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_DivisionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_DivisionAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs exclusive-or between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to exclusive-or with <paramref name="y" />.</param>
            <param name="y">The tensor to exclusive-or with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> ^ <paramref name="y" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="y" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Performs exclusive-or between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to exclusive-or with <paramref name="y" />.</param>
            <param name="y">The scalar to exclusive-or with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> ^ <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs exclusive-or between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to exclusive-or with <paramref name="y" />.</param>
            <param name="y">The tensor to exclusive-or with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> ^ <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" />, <paramref name="y" />, and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs exclusive-or between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to exclusive-or with <paramref name="y" />.</param>
            <param name="y">The scalar to exclusive-or with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> ^ <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_ExclusiveOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_ExclusiveOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_ExclusiveOr(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOr(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOr(System.Numerics.Tensors.Tensor{`0},`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(``0,System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOr(`0,System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOrAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOrAssignment``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOrAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOr(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOr(System.Numerics.Tensors.TensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOr(`0,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_ExclusiveOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOrAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Increment``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs an increment on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to increment.</param>
            <returns>A new tensor containing the result of ++<paramref name="x" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Increment``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs an increment on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to increment.</param>
            <param name="destination">The destination where the result of ++<paramref name="x" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_IncrementAssignment``1(System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$8FB18CAADE0EC02998C7015788839F7B`1.op_IncrementAssignment"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_IncrementAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$08E7CDA8B528F0FBB9B63F41630F3648`1.op_IncrementAssignment"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ShiftLeft``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>Performs an element-wise left shift on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to left shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> &lt;&lt; <paramref name="shiftAmount" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ShiftLeft``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs an element-wise left shift on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to left shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> &lt;&lt; <paramref name="shiftAmount" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$7B3E852987114D65CF0A6BE49DF1AFD1`1.op_LeftShift(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_LeftShift(System.Numerics.Tensors.Tensor{`0},System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_LeftShiftAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_LeftShiftAssignment(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_LeftShift(System.Numerics.Tensors.TensorSpan{`0}@,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_LeftShiftAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_LeftShiftAssignment(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs element-wise multiplication between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to multiply with <paramref name="y" />.</param>
            <param name="y">The tensor to multiply with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> * <paramref name="y" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="y" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Performs element-wise multiplication between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to multiply with <paramref name="y" />.</param>
            <param name="y">The scalar to multiply with <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> * <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise multiplication between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to multiply with <paramref name="y" />.</param>
            <param name="y">The tensor to multiply with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> * <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" />, <paramref name="y" />, and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise multiplication between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to multiply with <paramref name="y" />.</param>
            <param name="y">The scalar to multiply with <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> * <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EE370FE0DCC484E8A0E26F357297EE8A`1.op_Multiply(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EE370FE0DCC484E8A0E26F357297EE8A`1.op_Multiply(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EE370FE0DCC484E8A0E26F357297EE8A`1.op_Multiply(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_Multiply(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_Multiply(System.Numerics.Tensors.Tensor{`0},`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(``0,System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_Multiply(`0,System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_MultiplicationAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_MultiplicationAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_MultiplicationAssignment``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_MultiplicationAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_Multiply(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_Multiply(System.Numerics.Tensors.TensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Multiply``1(``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_Multiply(`0,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_MultiplicationAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_MultiplicationAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_MultiplicationAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_MultiplicationAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs a one's complement on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to one's complement.</param>
            <returns>A new tensor containing the result of ~<paramref name="x" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs a one's complement on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to one's complement.</param>
            <param name="destination">The destination where the result of ~<paramref name="x" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_OnesComplement(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_OnesComplement``1(System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_OnesComplement(System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_OnesComplement``1(System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_OnesComplement(System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ShiftRightArithmetic``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>Performs an element-wise arithmetic right shift on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to arithmetic right shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> &gt;&gt; <paramref name="shiftAmount" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ShiftRightArithmetic``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs an element-wise arithmetic right shift on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to arithmetic right shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> &gt;&gt; <paramref name="shiftAmount" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_RightShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$7B3E852987114D65CF0A6BE49DF1AFD1`1.op_RightShift(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_RightShift``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_RightShift(System.Numerics.Tensors.Tensor{`0},System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_RightShiftAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_RightShiftAssignment(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_RightShift``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_RightShift(System.Numerics.Tensors.TensorSpan{`0}@,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_RightShiftAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_RightShiftAssignment(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs element-wise subtraction between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor from which to subtract <paramref name="y" />.</param>
            <param name="y">The tensor to subtract from <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> - <paramref name="y" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="y" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <summary>Performs element-wise subtraction between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor from which to subtract <paramref name="y" />.</param>
            <param name="y">The scalar to subtract from <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> - <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs element-wise subtraction between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The scalar from which to subtract <paramref name="y" />.</param>
            <param name="y">The tensor to subtract from <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> - <paramref name="y" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise subtraction between two tensors.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor from which to subtract <paramref name="y" />.</param>
            <param name="y">The tensor to subtract from <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> - <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" />, <paramref name="y" />, and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise subtraction between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor from which to subtract <paramref name="y" />.</param>
            <param name="y">The scalar to subtract from <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> - <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise subtraction between a tensor and scalar.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The scalar from which to subtract <paramref name="y" />.</param>
            <param name="y">The tensor to subtract from <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> - <paramref name="y" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="y" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$2A4286E6AF1C038195D63DA56E1CFB07`1.op_Subtraction(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$2A4286E6AF1C038195D63DA56E1CFB07`1.op_Subtraction(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$2A4286E6AF1C038195D63DA56E1CFB07`1.op_Subtraction(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_Subtraction(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_Subtraction(System.Numerics.Tensors.Tensor{`0},`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(``0,System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_Subtraction(`0,System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_SubtractionAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_SubtractionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_SubtractionAssignment``1(System.Numerics.Tensors.Tensor{``0},``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_SubtractionAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_Subtraction(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_Subtraction(System.Numerics.Tensors.TensorSpan{`0}@,`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(``0,System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_Subtraction(`0,System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_SubtractionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_SubtractionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_SubtractionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_SubtractionAssignment(`0)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Performs element-wise unary negation on a tensor.</summary>
            <param name="x">The tensor to negate.</param>
            <returns>A new tensor containing the result of -<paramref name="x" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs element-wise unary negation on a tensor.</summary>
            <param name="x">The tensor to negate.</param>
            <param name="destination">The destination where the result of -<paramref name="x" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnaryNegation``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$64B924DFCD9E7A15A66BB082C2808F1F`1.op_UnaryNegation(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnaryNegation``1(System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EA26CA28C5139A27ECBB026A866FF156`1.op_UnaryNegation(System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnaryNegation``1(System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A067E63833C26B584399D1ADC77FBC26`1.op_UnaryNegation(System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnaryPlus``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$6F3EAAADE110F94EF3FD2DE604BF1E4A`1.op_UnaryPlus(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnaryPlus``1(System.Numerics.Tensors.Tensor{``0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$BB418A230ABF36B315C990D809465EC0`1.op_UnaryPlus(System.Numerics.Tensors.Tensor{`0})"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnaryPlus``1(System.Numerics.Tensors.TensorSpan{``0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$718B3D84D176CC6696D67A09F43B312D`1.op_UnaryPlus(System.Numerics.Tensors.TensorSpan{`0}@)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ShiftRightLogical``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <summary>Performs an element-wise logical right shift on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to logical right shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="x" />.</param>
            <returns>A new tensor containing the result of <paramref name="x" /> &gt;&gt;&gt; <paramref name="shiftAmount" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.ShiftRightLogical``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Performs an element-wise logical right shift on a tensor.</summary>
            <typeparam name="T">The type of the elements in the tensor.</typeparam>
            <param name="x">The tensor to logical right shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="x" />.</param>
            <param name="destination">The destination where the result of <paramref name="x" /> &gt;&gt;&gt; <paramref name="shiftAmount" /> is written.</param>
            <returns>A reference to <paramref name="destination" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="x" /> and <paramref name="destination" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnsignedRightShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$7B3E852987114D65CF0A6BE49DF1AFD1`1.op_UnsignedRightShift(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnsignedRightShift``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_UnsignedRightShift(System.Numerics.Tensors.Tensor{`0},System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnsignedRightShiftAssignment``1(System.Numerics.Tensors.Tensor{``0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_UnsignedRightShiftAssignment(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnsignedRightShift``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_UnsignedRightShift(System.Numerics.Tensors.TensorSpan{`0}@,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.op_UnsignedRightShiftAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_UnsignedRightShiftAssignment(System.Int32)"/>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$C73EBF61CD0A1187D8FDBF1BBD2D8347`1.&lt;M&gt;$0950BB810247C96034670232A260B3D6">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C73EBF61CD0A1187D8FDBF1BBD2D8347`1.op_Addition(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise addition between two tensors.</summary>
            <param name="left">The tensor to add with <paramref name="right" />.</param>
            <param name="right">The tensor to add with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> + <paramref name="right" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="left" /> and <paramref name="right" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C73EBF61CD0A1187D8FDBF1BBD2D8347`1.op_Addition(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)">
            <summary>Performs element-wise addition between a tensor and scalar.</summary>
            <param name="left">The tensor to add with <paramref name="right" />.</param>
            <param name="right">The scalar to add with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> + <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C73EBF61CD0A1187D8FDBF1BBD2D8347`1.op_Addition(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise addition between a tensor and scalar.</summary>
            <param name="left">The scalar to add with <paramref name="right" />.</param>
            <param name="right">The tensor to add with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> + <paramref name="right" />.</returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.&lt;M&gt;$6B8224951D94B4C2E3D73A75BCC1B539">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_Addition(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_Addition(System.Numerics.Tensors.Tensor{`0},`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_Addition(`0,System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Addition``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_AdditionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_AdditionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$B6EAC41E7FD26AB3137F9B7A45AE36F0`1.op_AdditionAssignment(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_AdditionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.&lt;M&gt;$2DE0EEB7F68A5AEBD621BE138D5B0253">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_Addition(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_Addition(System.Numerics.Tensors.TensorSpan{`0}@,`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Addition``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_Addition(`0,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Addition``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_AdditionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs in-place element-wise addition between two tensors.</summary>
            <param name="other">The tensor to add to the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$72B9B4120A764E0A07B9794EF88815C1`1.op_AdditionAssignment(`0)">
            <summary>Performs in-place element-wise addition between a tensor and scalar.</summary>
            <param name="other">The scalar to add to the tensor being operated on.</param>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.&lt;M&gt;$EA63DCD9C746481D6E913521439373AB">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseAnd(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs bitwise-and between two tensors.</summary>
            <param name="left">The tensor to bitwise-and with <paramref name="right" />.</param>
            <param name="right">The tensor to bitwise-and with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> &amp; <paramref name="right" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="left" /> and <paramref name="right" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseAnd(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)">
            <summary>Performs bitwise-and between a tensor and scalar.</summary>
            <param name="left">The tensor to bitwise-and with <paramref name="right" />.</param>
            <param name="right">The scalar to bitwise-and with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> &amp; <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseAnd(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs bitwise-and between a tensor and scalar.</summary>
            <param name="left">The scalar to bitwise-and with <paramref name="right" />.</param>
            <param name="right">The tensor to bitwise-and with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> &amp; <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs bitwise-or between two tensors.</summary>
            <param name="left">The tensor to bitwise-or with <paramref name="right" />.</param>
            <param name="right">The tensor to bitwise-or with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> | <paramref name="right" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="left" /> and <paramref name="right" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)">
            <summary>Performs bitwise-or between a tensor and scalar.</summary>
            <param name="left">The tensor to bitwise-or with <paramref name="right" />.</param>
            <param name="right">The scalar to bitwise-or with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> | <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_BitwiseOr(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs bitwise-or between a tensor and scalar.</summary>
            <param name="left">The scalar to bitwise-or with <paramref name="right" />.</param>
            <param name="right">The tensor to bitwise-or with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> | <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_ExclusiveOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs exclusive-or between two tensors.</summary>
            <param name="left">The tensor to exclusive-or with <paramref name="right" />.</param>
            <param name="right">The tensor to exclusive-or with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> ^ <paramref name="right" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="left" /> and <paramref name="right" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_ExclusiveOr(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)">
            <summary>Performs exclusive-or between a tensor and scalar.</summary>
            <param name="left">The tensor to exclusive-or with <paramref name="right" />.</param>
            <param name="right">The scalar to exclusive-or with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> ^ <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_ExclusiveOr(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs exclusive-or between a tensor and scalar.</summary>
            <param name="left">The scalar to exclusive-or with <paramref name="right" />.</param>
            <param name="right">The tensor to exclusive-or with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> ^ <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$D9E4183FC275B9B07CFB3981C6D65D2E`1.op_OnesComplement(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs a one's complement on a tensor.</summary>
            <param name="tensor">The tensor to one's complement.</param>
            <returns>A new tensor containing the result of ~<paramref name="tensor" />.</returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.&lt;M&gt;$757A2952E05FF498897438DD1277BE12">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAnd(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAnd(System.Numerics.Tensors.Tensor{`0},`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAnd(`0,System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAndAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAndAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseAndAssignment(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAndAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOr(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOr(System.Numerics.Tensors.Tensor{`0},`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOr(`0,System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_BitwiseOrAssignment(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOr(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOr(System.Numerics.Tensors.Tensor{`0},`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOr(`0,System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_ExclusiveOrAssignment(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOrAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.&lt;M&gt;$A02651CA84AB65B3C95FCC761E4D0D9A">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$CDC27BAA659446373CD874FEB0D696F5`1.op_OnesComplement(System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.&lt;M&gt;$2092BF6E9C070CE257736DC5287BE643">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAnd(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAnd(System.Numerics.Tensors.TensorSpan{`0}@,`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAnd(`0,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseAnd``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAndAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs in-place bitwise-and between two tensors.</summary>
            <param name="other">The tensor to bitwise-and with the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseAndAssignment(`0)">
            <summary>Performs in-place bitwise-and between a tensor and scalar.</summary>
            <param name="other">The scalar to bitwise-and with the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOr(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOr(System.Numerics.Tensors.TensorSpan{`0}@,`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOr(`0,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_BitwiseOr``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs in-place bitwise-or between two tensors.</summary>
            <param name="other">The tensor to bitwise-or with the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_BitwiseOrAssignment(`0)">
            <summary>Performs in-place bitwise-or between a tensor and scalar.</summary>
            <param name="other">The scalar to bitwise-or with the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOr(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOr(System.Numerics.Tensors.TensorSpan{`0}@,`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOr(`0,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_ExclusiveOr``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOrAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs in-place exclusive-or between two tensors.</summary>
            <param name="other">The tensor to exclusive-or with the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_ExclusiveOrAssignment(`0)">
            <summary>Performs in-place exclusive-or between a tensor and scalar.</summary>
            <param name="other">The scalar to exclusive-or with the tensor being operated on.</param>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.&lt;M&gt;$66BBAFC28178B3FE2221C6A39D89E333">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$650F30A31A40FB5CC3043AFCE35209D3`1.op_OnesComplement(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$F3C6A6407EFD24140A9D94B397075922`1.&lt;M&gt;$4C0B330C5CF21BE1E79DC7DDE3B59C50">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$F3C6A6407EFD24140A9D94B397075922`1.op_DecrementAssignment">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_DecrementAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$6825342FD39A3FDA3F46942F60CE3B4C`1.&lt;M&gt;$96AF23C9B25A4B0F3F7D3021196B1E00">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$6825342FD39A3FDA3F46942F60CE3B4C`1.op_DecrementAssignment">
            <summary>Performs in-place decrement on a tensor.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$11ECEC3835A71DB7BDDB2EA6F4E3B0EA`1.&lt;M&gt;$578D4383B6F049B4A96D85422BF88A73">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$11ECEC3835A71DB7BDDB2EA6F4E3B0EA`1.op_Division(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise division between two tensors.</summary>
            <param name="left">The tensor dividend.</param>
            <param name="right">The tensor divisor.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> / <paramref name="right" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="left" /> and <paramref name="right" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$11ECEC3835A71DB7BDDB2EA6F4E3B0EA`1.op_Division(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)">
            <summary>Performs element-wise division between a tensor and scalar.</summary>
            <param name="left">The tensor dividend.</param>
            <param name="right">The scalar divisor.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> / <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$11ECEC3835A71DB7BDDB2EA6F4E3B0EA`1.op_Division(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise division between a tensor and scalar.</summary>
            <param name="left">The scalar dividend.</param>
            <param name="right">The tensor divisor.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> / <paramref name="right" />.</returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.&lt;M&gt;$8765B0A55DE616E34D7FEB292FB581F4">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_Division(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_Division(System.Numerics.Tensors.Tensor{`0},`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_Division(`0,System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Division``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_DivisionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_DivisionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$618ABEA65F86CF539E6580E2710CDF4F`1.op_DivisionAssignment(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_DivisionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.&lt;M&gt;$331914880C9AAC2A6BD83F661B92B76A">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_Division(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_Division(System.Numerics.Tensors.TensorSpan{`0}@,`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Division``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_Division(`0,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Division``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_DivisionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs in-place element-wise division between two tensors.</summary>
            <param name="other">The tensor divisor.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$5C653C742CCA06FEB22BE55E4C352ED5`1.op_DivisionAssignment(`0)">
            <summary>Performs in-place element-wise division between a tensor and scalar.</summary>
            <param name="other">The scalar divisor.</param>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$8FB18CAADE0EC02998C7015788839F7B`1.&lt;M&gt;$FD3213559593374E179660012BB0E4F6">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$8FB18CAADE0EC02998C7015788839F7B`1.op_IncrementAssignment">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_IncrementAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$08E7CDA8B528F0FBB9B63F41630F3648`1.&lt;M&gt;$37C11AF376350B0316F88D14C1C56B74">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$08E7CDA8B528F0FBB9B63F41630F3648`1.op_IncrementAssignment">
            <summary>Performs in-place increment on a tensor.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$7B3E852987114D65CF0A6BE49DF1AFD1`1.&lt;M&gt;$A710C7C139A3DF862B3AA4EE5C9397D2">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$7B3E852987114D65CF0A6BE49DF1AFD1`1.op_LeftShift(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Int32)">
            <summary>Performs an element-wise left shift on a tensor.</summary>
            <param name="tensor">The tensor to left shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="tensor" />.</param>
            <returns>A new tensor containing the result of <paramref name="tensor" /> &lt;&lt; <paramref name="shiftAmount" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$7B3E852987114D65CF0A6BE49DF1AFD1`1.op_RightShift(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Int32)">
            <summary>Performs an element-wise arithmetic right shift on a tensor.</summary>
            <param name="tensor">The tensor to arithmetic right shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="tensor" />.</param>
            <returns>A new tensor containing the result of <paramref name="tensor" /> &gt;&gt; <paramref name="shiftAmount" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$7B3E852987114D65CF0A6BE49DF1AFD1`1.op_UnsignedRightShift(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Int32)">
            <summary>Performs an element-wise logical right shift on a tensor.</summary>
            <param name="tensor">The tensor to logical right shift.</param>
            <param name="shiftAmount">The amount to shift each element in <paramref name="tensor" />.</param>
            <returns>A new tensor containing the result of <paramref name="tensor" /> &gt;&gt;&gt; <paramref name="shiftAmount" />.</returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.&lt;M&gt;$414744D1E83FC94C7839A89133BE042B">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_LeftShift(System.Numerics.Tensors.Tensor{`0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_RightShift(System.Numerics.Tensors.Tensor{`0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_UnsignedRightShift(System.Numerics.Tensors.Tensor{`0},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.&lt;M&gt;$4C40F19609CBB8FCE26006AE2961C6DC">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_LeftShiftAssignment(System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShiftAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_RightShiftAssignment(System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShiftAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$68D13B79445EDBCB590C487EDA68EEDD`1.op_UnsignedRightShiftAssignment(System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShiftAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.&lt;M&gt;$99D7D482384683A971A1959C6C86EDC6">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_LeftShift(System.Numerics.Tensors.TensorSpan{`0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_RightShift(System.Numerics.Tensors.TensorSpan{`0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_UnsignedRightShift(System.Numerics.Tensors.TensorSpan{`0}@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_LeftShift``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.&lt;M&gt;$FE2E5341469FFF2E93DFDF1A96954D9B">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_LeftShiftAssignment(System.Int32)">
            <summary>Performs in-place element-wise left shift on a tensor.</summary>
            <param name="shiftAmount">The amount to shift each element in the tensor.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_RightShiftAssignment(System.Int32)">
            <summary>Performs in-place element-wise arithmetic right shift on a tensor.</summary>
            <param name="shiftAmount">The amount to shift each element in the tensor.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$C9AB810EACA197789317298D254FEF96`1.op_UnsignedRightShiftAssignment(System.Int32)">
            <summary>Performs in-place element-wise logical right shift on a tensor.</summary>
            <param name="shiftAmount">The amount to shift each element in the tensor.</param>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$EE370FE0DCC484E8A0E26F357297EE8A`1.&lt;M&gt;$EA0F3278524ED72857E2A9342D2B0DA9">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EE370FE0DCC484E8A0E26F357297EE8A`1.op_Multiply(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise multiplication between two tensors.</summary>
            <param name="left">The tensor to multiply with <paramref name="right" />.</param>
            <param name="right">The tensor to multiply with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> * <paramref name="right" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="left" /> and <paramref name="right" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EE370FE0DCC484E8A0E26F357297EE8A`1.op_Multiply(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)">
            <summary>Performs element-wise multiplication between a tensor and scalar.</summary>
            <param name="left">The tensor to multiply with <paramref name="right" />.</param>
            <param name="right">The scalar to multiply with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> * <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EE370FE0DCC484E8A0E26F357297EE8A`1.op_Multiply(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise multiplication between a tensor and scalar.</summary>
            <param name="left">The scalar to multiply with <paramref name="right" />.</param>
            <param name="right">The tensor to multiply with <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> * <paramref name="right" />.</returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.&lt;M&gt;$A2FB0FFBF5FDEC341A1396EEE2AECBE7">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_Multiply(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_Multiply(System.Numerics.Tensors.Tensor{`0},`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_Multiply(`0,System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Multiply``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_MultiplicationAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_MultiplicationAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$E00E19353F95C5AEB07B5A9721CC39D2`1.op_MultiplicationAssignment(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_MultiplicationAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.&lt;M&gt;$DF8A0009556DA7D1315BF48319C8C1DA">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_Multiply(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_Multiply(System.Numerics.Tensors.TensorSpan{`0}@,`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_Multiply(`0,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Multiply``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_MultiplicationAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs in-place element-wise multiplication between two tensors.</summary>
            <param name="other">The tensor used to multiply the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$DA50153CC5845951E014FF4FE92B697B`1.op_MultiplicationAssignment(`0)">
            <summary>Performs in-place element-wise multiplication between a tensor and scalar.</summary>
            <param name="other">The scalar used to multiply the tensor being operated on.</param>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$2A4286E6AF1C038195D63DA56E1CFB07`1.&lt;M&gt;$813D5DADCEEAC56CDEF075E0186B46B8">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$2A4286E6AF1C038195D63DA56E1CFB07`1.op_Subtraction(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise subtraction between two tensors.</summary>
            <param name="left">The tensor from which to subtract <paramref name="right" />.</param>
            <param name="right">The tensor to subtract from <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> - <paramref name="right" />.</returns>
            <exception cref="T:System.ArgumentException">The shapes of <paramref name="left" /> and <paramref name="right" /> are not compatible.</exception>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$2A4286E6AF1C038195D63DA56E1CFB07`1.op_Subtraction(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,`0)">
            <summary>Performs element-wise subtraction between a tensor and scalar.</summary>
            <param name="left">The tensor from which to subtract <paramref name="right" />.</param>
            <param name="right">The scalar to subtract from <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> - <paramref name="right" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$2A4286E6AF1C038195D63DA56E1CFB07`1.op_Subtraction(`0,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise subtraction between a tensor and scalar.</summary>
            <param name="left">The scalar from which to subtract <paramref name="right" />.</param>
            <param name="right">The tensor to subtract from <paramref name="left" />.</param>
            <returns>A new tensor containing the result of <paramref name="left" /> - <paramref name="right" />.</returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.&lt;M&gt;$9B931F5678C7999CB9425F1354707F81">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_Subtraction(System.Numerics.Tensors.Tensor{`0},System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_Subtraction(System.Numerics.Tensors.Tensor{`0},`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_Subtraction(`0,System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_SubtractionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_SubtractionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$61FC519A88E072BD85A961BBF24EDA31`1.op_SubtractionAssignment(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_SubtractionAssignment``1(System.Numerics.Tensors.TensorSpan{``0}@,``0)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.&lt;M&gt;$A01A9531092F9DB9CDB20E6B888EECAB">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
            <param name="tensor">The tensor to operate on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_Subtraction(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_Subtraction(System.Numerics.Tensors.TensorSpan{`0}@,`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_Subtraction(`0,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_Subtraction``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_SubtractionAssignment(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs in-place element-wise subtraction between two tensors.</summary>
            <param name="other">The tensor to subtract from the tensor being operated on.</param>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A3CEAD6D0793576ACF1EABBD275E177F`1.op_SubtractionAssignment(`0)">
            <summary>Performs in-place element-wise subtraction between a tensor and scalar.</summary>
            <param name="other">The scalar to subtract from the tensor being operated on.</param>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$64B924DFCD9E7A15A66BB082C2808F1F`1.&lt;M&gt;$A99CA9E1C3E65245EE1E3C3389125DEE">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$64B924DFCD9E7A15A66BB082C2808F1F`1.op_UnaryNegation(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise unary negation on a tensor.</summary>
            <param name="tensor">The tensor to negate.</param>
            <returns>A new tensor containing the result of -<paramref name="tensor" />.</returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$EA26CA28C5139A27ECBB026A866FF156`1.&lt;M&gt;$3C8E9FCB16299EF198EBF03892A7206C">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$EA26CA28C5139A27ECBB026A866FF156`1.op_UnaryNegation(System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_UnaryNegation``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$A067E63833C26B584399D1ADC77FBC26`1.&lt;M&gt;$3C51C38E796D60E4D278A6A312FA856A">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$A067E63833C26B584399D1ADC77FBC26`1.op_UnaryNegation(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_UnaryNegation``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$6F3EAAADE110F94EF3FD2DE604BF1E4A`1.&lt;M&gt;$AA133B913EE74A0F1E28F212A418FDA9">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$6F3EAAADE110F94EF3FD2DE604BF1E4A`1.op_UnaryPlus(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)">
            <summary>Performs element-wise unary plus on a tensor.</summary>
            <param name="tensor">The tensor to return.</param>
            <returns><paramref name="tensor" /></returns>
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$BB418A230ABF36B315C990D809465EC0`1.&lt;M&gt;$A9D577CDD569896C6E4D970317512912">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$BB418A230ABF36B315C990D809465EC0`1.op_UnaryPlus(System.Numerics.Tensors.Tensor{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_UnaryPlus``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor.&lt;G&gt;$718B3D84D176CC6696D67A09F43B312D`1.&lt;M&gt;$0BF591ACE3AE0894A298DF05657C76D6">
            <typeparam name="TScalar">The type of the elements in the tensor.</typeparam>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor.&lt;G&gt;$718B3D84D176CC6696D67A09F43B312D`1.op_UnaryPlus(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.Tensor.op_UnaryPlus``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor`1">
            <summary>
            Represents a tensor.
            </summary>
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Empty">
            <summary>Gets an empty tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.FlattenedLength">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.FlattenedLength" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.HasAnyDenseDimensions">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.HasAnyDenseDimensions" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.IsDense">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsDense" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.IsEmpty">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsEmpty" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.IsPinned">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsPinned" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Lengths">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Lengths" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Rank">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" />
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Strides">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Strides" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.op_Implicit(`0[])~System.Numerics.Tensors.Tensor{`0}">
            <summary>Defines an implicit conversion of an array to a tensor.</summary>
            <param name="array">The array to convert to a tensor.</param>
            <returns>The tensor span that corresponds to <paramref name="array" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.op_Implicit(System.Numerics.Tensors.Tensor{`0})~System.Numerics.Tensors.TensorSpan{`0}">
            <summary>Defines an implicit conversion of a tensor to a tensor span.</summary>
            <param name="tensor">The tensor to convert to a tensor span.</param>
            <returns>The tensor that corresponds to <paramref name="tensor" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.op_Implicit(System.Numerics.Tensors.Tensor{`0})~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}">
            <inheritdoc cref="M:System.Numerics.Tensors.TensorSpan`1.op_Implicit(System.Numerics.Tensors.TensorSpan{`0}@)~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.Clear">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor.Clear" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.CopyTo(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.CopyTo(System.Numerics.Tensors.TensorSpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.Fill(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.Fill(`1)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.FlattenTo(System.Span{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenTo(System.Span{`1})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.GetDimensionSpan(System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetDimensionSpan(System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.GetEnumerator">
            <summary>Gets an enumerator for the readonly tensor.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.GetPinnableReference">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetPinnableReference" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.GetPinnedHandle">
            <summary>Pins and gets a <see cref="T:System.Buffers.MemoryHandle"/> to the backing memory.</summary>
            <returns><see cref="T:System.Buffers.MemoryHandle"/></returns>
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.ToDenseTensor">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.ToDenseTensor" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.TryCopyTo(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryCopyTo(System.Numerics.Tensors.TensorSpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.TryFlattenTo(System.Span{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryFlattenTo(System.Span{`1})" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.Span{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.Span{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.Span{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.Span{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.ToString">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.ToString" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.ToString(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.ToString(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="T:System.Numerics.Tensors.Tensor`1.Enumerator">
            <summary>Enumerates the elements of a tensor.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.Tensor`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext" />
        </member>
        <member name="M:System.Numerics.Tensors.Tensor`1.Enumerator.Reset">
            <inheritdoc cref="M:System.Collections.IEnumerator.Reset" />
        </member>
        <member name="T:System.Numerics.Tensors.TensorDimensionSpan`1">
            <summary>Represents the slices that exist within a dimension of a tensor span.</summary>
            <typeparam name="T">The type of the elements within the tensor span.</typeparam>
        </member>
        <member name="P:System.Numerics.Tensors.TensorDimensionSpan`1.IsDense">
            <summary>Gets <c>true</c> if the slices that exist within the tracked dimension are dense; otherwise, <c>false</c>.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.TensorDimensionSpan`1.Length">
            <summary>Gets the length of the tensor dimension span.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.TensorDimensionSpan`1.Item(System.IntPtr)">
            <summary>Gets the tensor span representing a slice of the tracked dimension using the specified index.</summary>
            <param name="index">The index of the tensor span slice to retrieve within the tracked dimension.</param>
            <returns>The tensor span representing a slice of the tracked dimension using <paramref name="index" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorDimensionSpan`1.op_Implicit(System.Numerics.Tensors.TensorDimensionSpan{`0}@)~System.Numerics.Tensors.ReadOnlyTensorDimensionSpan{`0}">
            <summary>Defines an implicit conversion of a tensor dimension span to a readonly tensor dimension span.</summary>
            <param name="tensorDimension">The tensor dimension span to convert to a readonly tensor dimension span.</param>
            <returns>The tensor dimension span that corresponds to <paramref name="tensorDimension" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorDimensionSpan`1.GetEnumerator">
            <summary>Gets an enumerator for the readonly tensor dimension span.</summary>
        </member>
        <member name="T:System.Numerics.Tensors.TensorDimensionSpan`1.Enumerator">
            <summary>Enumerates the spans of a tensor dimension span.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.TensorDimensionSpan`1.Enumerator.Current">
            <summary>Gets the span at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorDimensionSpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the tensor span.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorDimensionSpan`1.Enumerator.Reset">
            <summary>Sets the enumerator to its initial position, which is before the first element in the tensor span.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorOperation.CosineSimilarity`1.Invoke(`0@,`0@,System.ValueTuple{`0,`0,`0}@)">
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (<typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(x)) * <typeparamref name="T"/>.Sqrt(TensorPrimitives.SumOfSquares(y)).</c>
        </member>
        <member name="T:System.Numerics.Tensors.TensorSpan`1">
            <summary>
            Represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type-safe and memory-safe.
            </summary>
            <typeparam name="T">The type of the elements within the tensor span.</typeparam>
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Empty">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor`2.Empty" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[])">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[])" />
            <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array"/> is covariant and its type is not exactly T[].</exception>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr})" />
            <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array"/> is covariant and its type is not exactly T[].</exception>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
            <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array"/> is covariant and its type is not exactly T[].</exception>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
            <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array"/> is covariant and its type is not exactly T[].</exception>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Span{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Span{`0},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Span{`0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Array)">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.Array)"/>
            <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array"/> is covariant and its type is not exactly T[].</exception>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Array,System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.Array,System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
            <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array"/> is covariant and its type is not exactly T[].</exception>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0*,System.IntPtr)">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.FlattenedLength">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.FlattenedLength" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.HasAnyDenseDimensions">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.HasAnyDenseDimensions" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.IsDense">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsDense" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.IsEmpty">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsEmpty" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.IsPinned">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsPinned" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Lengths">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Lengths" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Rank">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" />
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Strides">
            <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Strides" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.op_Equality(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Equality(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.op_Inequality(System.Numerics.Tensors.TensorSpan{`0}@,System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Inequality(System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{`0}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.op_Implicit(`0[])~System.Numerics.Tensors.TensorSpan{`0}">
            <summary>Defines an implicit conversion of an array to a tensor span.</summary>
            <param name="array">The array to convert to a tensor span.</param>
            <returns>The tensor span that corresponds to <paramref name="array" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.op_Implicit(System.Numerics.Tensors.TensorSpan{`0}@)~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}">
            <summary>Defines an implicit conversion of a tensor to a readonly tensor span.</summary>
            <param name="tensor">The tensor to convert to a readonly tensor span.</param>
            <returns>The tensor that corresponds to <paramref name="tensor" />.</returns>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.AsReadOnlyTensorSpan">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Clear">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor.Clear" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.CopyTo(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.CopyTo(System.Numerics.Tensors.TensorSpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Equals(System.Object)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Fill(`0)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.Fill(`1)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.FlattenTo(System.Span{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenTo(System.Span{`1})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.GetDimensionSpan(System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetDimensionSpan(System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.GetEnumerator">
            <summary>Gets an enumerator for the tensor span.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.GetHashCode">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetHashCode" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.GetPinnableReference">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetPinnableReference" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Slice(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NIndex})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NRange})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.ToString">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.ToString" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.ToString(System.ReadOnlySpan{System.IntPtr})">
            <inheritdoc cref="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.ToString(System.ReadOnlySpan{System.IntPtr})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.TryCopyTo(System.Numerics.Tensors.TensorSpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryCopyTo(System.Numerics.Tensors.TensorSpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.TryFlattenTo(System.Span{`0})">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryFlattenTo(System.Span{`1})" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.Span{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.Span{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.Span{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.Span{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.IntPtr},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryGetSpan(System.ReadOnlySpan{System.Buffers.NIndex},System.Int32,System.ReadOnlySpan{`1}@)" />
        </member>
        <member name="T:System.Numerics.Tensors.TensorSpan`1.Enumerator">
            <summary>Enumerates the elements of a tensor span.</summary>
        </member>
        <member name="P:System.Numerics.Tensors.TensorSpan`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the span.</summary>
        </member>
        <member name="M:System.Numerics.Tensors.TensorSpan`1.Enumerator.Reset">
            <summary>Sets the enumerator to its initial position, which is before the first element in the tensor span.</summary>
        </member>
        <member name="T:System.Buffers.NIndex">
            <summary>Represents a type that can be used to index a collection either from the start or the end.</summary>
            <remarks>
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Buffers.NIndex.#ctor(System.IntPtr,System.Boolean)">
            <summary>Constructs an <see cref="T:System.Buffers.NIndex"/> using an index value and a Boolean that indicates if the <see cref="T:System.Buffers.NIndex"/> is from the start or from the end.</summary>
            <param name="value">The index value. It must be greater than or equal to zero.</param>
            <param name="fromEnd"><see langword="true"/> if the index is from the start; <see langword="false"/> if it's from the end.</param>
            <remarks>
            If the NIndex constructed from the end, an index value of 1 points at the last element and an index value of 0 points beyond the last element.
            </remarks>
        </member>
        <member name="M:System.Buffers.NIndex.#ctor(System.Index)">
            <summary>Constructs an <see cref="T:System.Buffers.NIndex"/> from an <see cref="T:System.Index"/>.</summary>
            <param name="index">The <see cref="T:System.Index"/> to create the <see cref="T:System.Buffers.NIndex"/> from.</param>
            <remarks>
            If the NIndex constructed from the end, an index value of 1 points at the last element and an index value of 0 points beyond the last element.
            </remarks>
        </member>
        <member name="P:System.Buffers.NIndex.Start">
            <summary>Creates an <see cref="T:System.Buffers.NIndex"/> that points at the first element.</summary>
        </member>
        <member name="P:System.Buffers.NIndex.End">
            <summary>Creates an <see cref="T:System.Buffers.NIndex"/> that points beyond the last element.</summary>
        </member>
        <member name="M:System.Buffers.NIndex.FromStart(System.IntPtr)">
            <summary>Creates an <see cref="T:System.Buffers.NIndex"/> from the start at the specified position.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Buffers.NIndex.FromEnd(System.IntPtr)">
            <summary>Creates an NIndex from the end at the specified position.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="M:System.Buffers.NIndex.ToIndex">
            <summary>
            Converts the <see cref="T:System.Buffers.NIndex"/> to an <see cref="T:System.Index"/>.
            </summary>
            <returns>The converted Index.</returns>
        </member>
        <member name="M:System.Buffers.NIndex.ToIndexUnchecked">
            <summary>
            Converts the <see cref="T:System.Buffers.NIndex"/> to an <see cref="T:System.Index"/> without doing bounds checks.
            </summary>
            <returns>The converted Index.</returns>
        </member>
        <member name="P:System.Buffers.NIndex.Value">
            <summary>Gets the <see cref="T:System.Buffers.NIndex"/> value.</summary>
        </member>
        <member name="P:System.Buffers.NIndex.IsFromEnd">
            <summary>Gets a value that indicates whether the <see cref="T:System.Buffers.NIndex"/> is from the start or the end.</summary>
        </member>
        <member name="M:System.Buffers.NIndex.GetOffset(System.IntPtr)">
            <summary>Calculates the offset from the start using the given collection length.</summary>
            <param name="length">The length of the collection that the NIndex will be used with. Must be a positive value.</param>
            <remarks>
            For performance reasons, the input length argument and the returned offset value aren't validated against negative values.
            Also, the returned offset might be greater than the input length.
            It is expected <see cref="T:System.Buffers.NIndex"/> will be used with collections that always have a non-negative length/count. If the returned offset is negative and
            then used to <see cref="T:System.Buffers.NIndex"/> a collection, an <see cref="T:System.ArgumentOutOfRangeException" /> is thrown, which has the same effect as the validation.
            </remarks>
        </member>
        <member name="M:System.Buffers.NIndex.Equals(System.Object)">
            <summary>Compares the current NIndex object to another object of the same type for equality.</summary>
            <param name="value">An object to compare with this object.</param>
        </member>
        <member name="M:System.Buffers.NIndex.Equals(System.Buffers.NIndex)">
            <summary>Compares the current <see cref="T:System.Buffers.NIndex"/> object to another <see cref="T:System.Buffers.NIndex"/> object for equality.</summary>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:System.Buffers.NIndex.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Buffers.NIndex.op_Implicit(System.IntPtr)~System.Buffers.NIndex">
            <summary>Converts an integer number to an NIndex.</summary>
        </member>
        <member name="M:System.Buffers.NIndex.op_Implicit(System.Index)~System.Buffers.NIndex">
            <summary>Converts a native integer number to an NIndex.</summary>
        </member>
        <member name="M:System.Buffers.NIndex.op_Explicit(System.Buffers.NIndex)~System.Index">
            <summary>Converts an <see cref="T:System.Buffers.NIndex"/> to an <see cref="T:System.Index"/>.</summary>
        </member>
        <member name="M:System.Buffers.NIndex.op_CheckedExplicit(System.Buffers.NIndex)~System.Index">
            <summary>Converts an <see cref="T:System.Buffers.NIndex"/> to an <see cref="T:System.Index"/>.</summary>
        </member>
        <member name="M:System.Buffers.NIndex.ToString">
            <summary>Converts the value of the current NIndex object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Buffers.NRange">
            <summary>Represents a range that has start and end indices.</summary>
            <remarks>
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Buffers.NRange.Start">
            <summary>Gets the inclusive start NIndex of the NRange.</summary>
        </member>
        <member name="P:System.Buffers.NRange.End">
            <summary>Gets the exclusive end NIndex of the NRange.</summary>
        </member>
        <member name="M:System.Buffers.NRange.#ctor(System.Buffers.NIndex,System.Buffers.NIndex)">
            <summary>Constructs an <see cref="T:System.Buffers.NRange"/> object using the start and end <see cref="T:System.Buffers.NIndex"/>.</summary>
            <param name="start">The inclusive start <see cref="T:System.Buffers.NIndex"/> of the <see cref="T:System.Buffers.NRange"/>.</param>
            <param name="end">The exclusive end <see cref="T:System.Buffers.NIndex"/> of the <see cref="T:System.Buffers.NRange"/>.</param>
        </member>
        <member name="M:System.Buffers.NRange.#ctor(System.Range)">
            <summary>
            Constructs an <see cref="T:System.Buffers.NRange"/> object using a <see cref="T:System.Range"/>.
            </summary>
            <param name="range">The <see cref="T:System.Range"/> to use.</param>
        </member>
        <member name="M:System.Buffers.NRange.Equals(System.Object)">
            <summary>Compares the current <see cref="T:System.Buffers.NRange"/> object to another object of the same type for equality.</summary>
            <param name="value">An object to compare with this object.</param>
        </member>
        <member name="M:System.Buffers.NRange.Equals(System.Buffers.NRange)">
            <summary>Compares the current <see cref="T:System.Buffers.NRange"/> object to another <see cref="T:System.Buffers.NRange"/> object for equality.</summary>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:System.Buffers.NRange.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Buffers.NRange.ToString">
            <summary>Converts the value of the current NRange object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Buffers.NRange.StartAt(System.Buffers.NIndex)">
            <summary>Creates an <see cref="T:System.Buffers.NRange"/> object starting from start <see cref="T:System.Buffers.NIndex"/> to the end of the collection.</summary>
        </member>
        <member name="M:System.Buffers.NRange.EndAt(System.Buffers.NIndex)">
            <summary>Creates an <see cref="T:System.Buffers.NRange"/> object starting from first element in the collection to the end <see cref="T:System.Buffers.NIndex"/>.</summary>
        </member>
        <member name="P:System.Buffers.NRange.All">
            <summary>Creates an NRange object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Buffers.NRange.GetOffsetAndLength(System.IntPtr)">
            <summary>Calculates the start offset and length of the <see cref="T:System.Buffers.NRange"/> object using a collection length.</summary>
            <param name="length">The length of the collection that the <see cref="T:System.Buffers.NRange"/> will be used with. Must be a positive value.</param>
            <remarks>
            For performance reasons, the input length parameter isn't validated against negative values.
            It's expected NRange will be used with collections that always have a non-negative length/count.
            The <see cref="T:System.Buffers.NRange"/> is validated to be inside the length scope, however.
            </remarks>
        </member>
        <member name="M:System.Buffers.NRange.op_Implicit(System.Range)~System.Buffers.NRange">
            <summary>
            Implicitly converts a <see cref="T:System.Range"/> to an <see cref="T:System.Buffers.NRange"/>.
            </summary>
            <param name="range"></param>
        </member>
        <member name="M:System.Buffers.NRange.op_Explicit(System.Buffers.NRange)~System.Range">
            <summary>
            Explicitly converts an <see cref="T:System.Buffers.NRange"/> to a <see cref="T:System.Range"/> without doing bounds checks.
            </summary>
            <param name="value"><see cref="T:System.Buffers.NRange"/> to convert.</param>
        </member>
        <member name="M:System.Buffers.NRange.op_CheckedExplicit(System.Buffers.NRange)~System.Range">
            <summary>
            Explicitly converts an <see cref="T:System.Buffers.NRange"/> to a <see cref="T:System.Range"/>.
            </summary>
            <param name="value"><see cref="T:System.Buffers.NRange"/> to convert.</param>
        </member>
        <member name="M:System.Buffers.NRange.ToRange">
            <summary>
            Converts a <see cref="T:System.Buffers.NRange"/> to a <see cref="T:System.Range"/>.
            </summary>
            <returns>The converted Range.</returns>
        </member>
        <member name="M:System.Buffers.NRange.ToRangeUnchecked">
            <summary>
            Converts a <see cref="T:System.Buffers.NRange"/> to a <see cref="T:System.Range"/> without doing bounds checks.
            </summary>
            <returns>The converted Range.</returns>
        </member>
        <member name="T:System.Runtime.InteropServices.TensorMarshal">
            <summary>Provides methods to interoperate with <see cref="T:System.Numerics.Tensors.Tensor`1" />, <see cref="T:System.Numerics.Tensors.TensorSpan`1" />, and <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</summary>
        </member>
        <member name="M:System.Runtime.InteropServices.TensorMarshal.CreateTensorSpan``1(``0@,System.IntPtr,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <summary>Creates a new tensor span over a portion of a regular managed object.</summary>
            <typeparam name="T">The type of the data items.</typeparam>
            <param name="data">A reference to data.</param>
            <param name="dataLength">The number of <typeparamref name="T" /> elements that <paramref name="data" /> contains.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor will have a single dimension that is the same length as <paramref name="dataLength" />.</param>
            <param name="strides">The strides of each dimension. If an empty span is provided, then strides will be automatically calculated from <paramref name="lengths" />.</param>
            <param name="pinned"><c>true</c> if <paramref name="data" /> is permanently pinned; otherwise, <c>false</c>.</param>
            <returns>The created tensor span.</returns>
            <remarks>This method should be used with caution. It is dangerous because the inputs may not be fully checked. Even though <paramref name="data" /> is marked as <c>scoped</c>, it will be stored into the returned tensor span, and the lifetime of the returned tensor span will not be validated for safety, even by span-aware languages.</remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.TensorMarshal.CreateReadOnlyTensorSpan``1(``0@,System.IntPtr,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)">
            <summary>Creates a new readonly tensor span over a portion of a regular managed object.</summary>
            <typeparam name="T">The type of the data items.</typeparam>
            <param name="data">A readonly reference to data.</param>
            <param name="dataLength">The number of <typeparamref name="T" /> elements that <paramref name="data" /> contains.</param>
            <param name="lengths">The lengths of the dimensions. If an empty span is provided, the created tensor will have a single dimension that is the same length as <paramref name="dataLength" />.</param>
            <param name="strides">The strides of each dimension. If an empty span is provided, then strides will be automatically calculated from <paramref name="lengths" />.</param>
            <param name="pinned"><c>true</c> if <paramref name="data" /> is permanently pinned; otherwise, <c>false</c>.</param>
            <returns>The created readonly tensor span.</returns>
            <remarks>This method should be used with caution. It is dangerous because the inputs may not be fully checked. Even though <paramref name="data" /> is marked as <c>scoped</c>, it will be stored into the returned tensor span, and the lifetime of the returned tensor span will not be validated for safety, even by span-aware languages.</remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.TensorMarshal.GetReference``1(System.Numerics.Tensors.TensorSpan{``0}@)">
            <summary>Returns a reference to the element of the tensor span at index 0.</summary>
            <typeparam name="T">The type of items in the tensor span.</typeparam>
            <param name="tensorSpan">The tensor span from which the reference is retrieved.</param>
            <returns>A reference to the element at index 0.</returns>
            <remarks>If the tensor span is empty, this method returns a reference to the location where the element at index 0 would have been stored. Such a reference may or may not be <c>null</c>. The returned reference can be used for pinning, but it must never be dereferenced.</remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.TensorMarshal.GetReference``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)">
            <summary>Returns a reference to the element of the readonly tensor span at index 0.</summary>
            <typeparam name="T">The type of items in the readonly tensor span.</typeparam>
            <param name="tensorSpan">The readonly tensor span from which the reference is retrieved.</param>
            <returns>A readonly reference to the element at index 0.</returns>
            <remarks>If the readonly tensor span is empty, this method returns a reference to the location where the element at index 0 would have been stored. Such a reference may or may not be <c>null</c>. The returned reference can be used for pinning, but it must never be dereferenced.</remarks>
        </member>
        <member name="P:System.SR.Argument_DestinationTooShort">
            <summary>Destination is too short.</summary>
        </member>
        <member name="P:System.SR.Argument_SpansMustBeNonEmpty">
            <summary>Input span arguments must not be empty.</summary>
        </member>
        <member name="P:System.SR.Argument_SpansMustHaveSameLength">
            <summary>Input span arguments must all have the same length.</summary>
        </member>
        <member name="P:System.SR.Argument_InputAndDestinationSpanMustNotOverlap">
            <summary>The destination span may only overlap with an input span if the two spans start at the same memory location.</summary>
        </member>
        <member name="P:System.SR.Argument_DestinationSpansMustNotOverlap">
            <summary>Destination spans must not overlap with each other.</summary>
        </member>
        <member name="P:System.SR.Overflow_NegateTwosCompNum">
            <summary>Negating the minimum value of a twos complement number is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidEnumValue">
            <summary>The value '{0}' is not valid for this usage of the type {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidTypeWithPointersNotSupported">
            <summary>Cannot use type '{0}'. Only value types without pointers or references are supported.</summary>
        </member>
        <member name="P:System.SR.DestinationTooShort">
            <summary>Destination is too short.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CannotCallEqualsOnSpan">
            <summary>Equals() on TensorSpan and ReadOnlyTensorSpan is not supported. Use operator== instead.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CannotCallGetHashCodeOnSpan">
            <summary>GetHashCode() on TensorSpan and ReadOnlyTensorSpan is not supported.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_IndicesLengthMustEqualRank">
            <summary>Number of Indices must equal the rank of the TensorSpan.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_LengthsMustEqualArrayLength">
            <summary>The total length specified by the lengths must equal the length of the array.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_1DTensorRequired">
            <summary>Must be a 1d tensor</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_AxisLargerThanRank">
            <summary>Cannot select an axis greater than the current Rank</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_ConcatenateTooFewTensors">
            <summary>Must provide at least 2 tensors to Concatenate</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_DimensionsNotSame">
            <summary>Number of dimensions to slice does not equal the number of dimensions in the span</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_FilterTensorMustEqualTensorLength">
            <summary>The total length of the filter tensor must equal the length of the tensor to be filtered.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_IncorrectNumberOfFilterItems">
            <summary>Number of elements provided does not match the number of filters.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_InPlaceInvalidShape">
            <summary>In place operations require the same shape for both tensors</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_InvalidDimension">
            <summary>Invalid dimension provided. Must be greater then or equal to 0 and less than the tensor rank.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_InvalidConcatenateShape">
            <summary>The tensors must have the same shape, except in the dimension corresponding to axis.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_InvalidReshapeDimensions">
            <summary>Provided dimensions are not valid for reshaping</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_InvalidSqueezeAxis">
            <summary>Cannot select an axis to squeeze which has size not equal to one</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_OnlyOneWildcard">
            <summary>Provided dimensions can only include 1 wildcard.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_PermuteAxisOrder">
            <summary>Must provide an axis order for each axis</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_SetSliceInvalidShapes">
            <summary>Provided values must have the same shape as the input tensor.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_SetSliceNoRange">
            <summary>When no ranges are specified the values tensor must be equal in size as the input tensor.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_LengthsNotCompatible">
            <summary>Lengths are not compatible with each other.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_SplitNotSplitEvenly">
            <summary>The number of splits must perfectly divide the dimension.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_StackTooFewTensors">
            <summary>Must provide at least 2 tensors to Stack.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_TransposeTooFewDimensions">
            <summary>Must provide a tensor with at least 2 dimensions to transpose it.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_ValueNonNegative">
            <summary>The provided value must be non-negative.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_InvalidStridesAndLengths">
            <summary>The provided lengths and strides would allow you to access elements outside the provided memory.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_StrideLessThan0">
            <summary>Strides cannot be less than 0.</summary>
        </member>
        <member name="P:System.SR.Argument_2DTensorRequired">
            <summary>Must be a 2d Tensor.</summary>
        </member>
        <member name="P:System.SR.Argument_IncompatibleDimensions">
            <summary>Incompatible dimensions for provided tensors. left.Lengths[1] == {0} while right.Lengths[1] == {1}.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_StackShapesNotSame">
            <summary>All tensors must have the same shape.</summary>
        </member>
        <member name="P:System.SR.Argument_CannotReshapeNonContiguousOrDense">
            <summary>The Tensor provided is either non-contiguous or non-dense. Reshape only works with contigous and dense memory. You may need to Broadcast or Copy the data to be contigous.</summary>
        </member>
        <member name="P:System.SR.Argument_MinGreaterThanMax">
            <summary>A minimum value may not be greater than a maximum value.</summary>
        </member>
        <member name="P:System.SR.Arithmetic_NaN">
            <summary>Function does not accept floating point Not-a-Number values.</summary>
        </member>
        <member name="P:System.SR.ThrowArgument_LengthIsNonZeroForNullReference">
            <summary>The provided length is non zero while the data reference is null.</summary>
        </member>
    </members>
</doc>
